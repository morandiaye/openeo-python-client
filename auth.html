
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Authentication and Account Management &#8212; openEO Python Client 0.6.2a1 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="User-Defined Functions (UDF) explained" href="udf.html" />
    <link rel="prev" title="User-Defined Processes" href="udp.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">openEO Python Client</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Open-EO&repo=openeo-python-client&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/Open-EO/openeo-python-client">
    <img
        alt="https://secure.travis-ci.org/Open-EO/openeo-python-client.svg?branch=master"
        src="https://secure.travis-ci.org/Open-EO/openeo-python-client.svg?branch=master"
    />
</a>
</p>



  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Authentication and Account Management</a><ul>
<li><a class="reference internal" href="#basic-http-auth">Basic HTTP Auth</a></li>
<li><a class="reference internal" href="#openid-connect-based-authentication">OpenID Connect Based Authentication</a><ul>
<li><a class="reference internal" href="#general-options">General options</a></li>
<li><a class="reference internal" href="#authorization-code-flow">Authorization Code Flow</a><ul>
<li><a class="reference internal" href="#basic-usage">Basic usage</a></li>
<li><a class="reference internal" href="#options-and-finetuning">Options and finetuning</a></li>
</ul>
</li>
<li><a class="reference internal" href="#device-flow">Device Flow</a></li>
<li><a class="reference internal" href="#client-credentials-flow">Client Credentials Flow</a></li>
<li><a class="reference internal" href="#resource-owner-password-flow">Resource Owner Password flow</a></li>
<li><a class="reference internal" href="#refresh-token-flow">Refresh Token Flow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#config-files-and-openeo-auth-helper-tool">Config files and <code class="docutils literal notranslate"><span class="pre">openeo-auth</span></code> helper tool</a><ul>
<li><a class="reference internal" href="#basic-http-auth-config">Basic HTTP Auth config</a></li>
<li><a class="reference internal" href="#openid-connect-configs">OpenID Connect configs</a><ul>
<li><a class="reference internal" href="#openid-connect-refresh-tokens">OpenID Connect refresh tokens</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="udp.html" title="previous chapter">User-Defined Processes</a></li>
      <li>Next: <a href="udf.html" title="next chapter">User-Defined Functions (UDF) explained</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script><!-- Alabaster (krTheme++) Hacks -->

<div class="sidebar-meta">
<h3>Meta</h3>
<div>Docs for openEO Python Client</div>
<div>Version: <code>0.6.2a1</code></div>
<div>Last updated: 2021/04/01</div>
</div>

<!-- CSS Adjustments from requests: https://github.com/kennethreitz/requests/blob/master/docs/_templates/hacks.html -->
<style type="text/css">
  /* Rezzy requires precise alignment. */
  img.logo {margin-left: -20px!important;}
  /* "Quick Search" should be capitalized. */
  div#searchbox h3 {text-transform: capitalize;}
  /* Make the document a little wider, less code is cut-off. */
  div.document {width: 1008px;}
  /* Much-improved spacing around code blocks. */
  div.highlight pre {padding: 11px 14px;}
  /* Remain Responsive! */
  @media screen and (max-width: 1008px) {
    div.sphinxsidebar {display: none;}
    div.document {width: 100%!important;}
    /* Have code blocks escape the document right-margin. */
    div.highlight pre {margin-right: -30px;}
  }

  /* Reduce space between paragraphs for better visual structure */
  p { margin: 1ex 0; }

  /* Hide "view source code" links by default, only show on hover */
  dt .viewcode-link { visibility: hidden; font-size: 70%; }
  dt:hover .viewcode-link { visibility: visible; }

  /* More breathing space between successive methods */
  dl { margin-bottom: 1.5em; }

  dl.field-list > dt {
      /* Cleaner aligning of Parameters/Returns/Raises listing with method description paragraphs */
      padding-left: 0;
      /* Make Parameters/Returns/Raises labels less dominant */
      text-transform: uppercase;
      font-size: 70%;
  }

  .sidebar-meta {
      font-size: 80%;
  }

</style>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="authentication-and-account-management">
<h1>Authentication and Account Management<a class="headerlink" href="#authentication-and-account-management" title="Permalink to this headline">¶</a></h1>
<p>While a couple of openEO operations can be done
anonymously, most of the interesting parts
of the API require you to identify as a registered
user.
The openEO API specifies two ways to authenticate
as a user:</p>
<ul class="simple">
<li><p>OpenID Connect (recommended, but not always straightforward to use)</p></li>
<li><p>Basic HTTP Authentication (not recommended, but practically easier in some situations)</p></li>
</ul>
<p>To illustrate how to authenticate with the openEO Python Client Library,
we start form a backend connection:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">openeo</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">openeo</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;https://openeo.example.com&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="basic-http-auth">
<h2>Basic HTTP Auth<a class="headerlink" href="#basic-http-auth" title="Permalink to this headline">¶</a></h2>
<p>Let’s start with the easiest authentication method,
based on the Basic HTTP authentication scheme.
It is however <em>not recommended</em> for various reasons,
such as its limited <em>security</em> measures.
For example, if you are connecting to a backend with a <code class="docutils literal notranslate"><span class="pre">http://</span></code> URL
instead of a <code class="docutils literal notranslate"><span class="pre">https://</span></code> one, you should certainly not use basic HTTP auth.</p>
<p>With these security related caveats out of the way, you authenticate
using your username and password like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_basic</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">,</span> <span class="s2">&quot;j0hn123&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Subsequent usage of the connection object <code class="docutils literal notranslate"><span class="pre">con</span></code> will
use authenticated calls.
For example, show information about the authenticated user:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">describe_account</span><span class="p">()</span>
<span class="go">{&#39;user_id&#39;: &#39;john&#39;}</span>
</pre></div>
</div>
</div>
<div class="section" id="openid-connect-based-authentication">
<h2>OpenID Connect Based Authentication<a class="headerlink" href="#openid-connect-based-authentication" title="Permalink to this headline">¶</a></h2>
<p>OpenID Connect is an identity layer on top of the OAuth 2.0 protocol.
It is a quite an extensive stack of interacting actors and protocols,
and an in-depth discussion of its architecture would lead us too far here.
However, in the context of working with openEO,
these OpenID Connect concepts are useful to understand:</p>
<ul>
<li><p>There is <strong>decoupling</strong> between:</p>
<ul class="simple">
<li><p>the <em>OpenID Connect identity provider</em> (the platform
that handles the authentication of the user)</p></li>
<li><p>the <em>openEO backend</em>, which manages earth observation collections
and executes your algorithms</p></li>
</ul>
<p>Instead of managing the authentication procedure itself,
a backend first forwards a user to the log-in page of
a OpenID Connect provider, such as an (external) organisation like Google or Microsoft.
The user can log in there with an existing account (or create a new one)
and then generally has to explicitly grant access
to basic profile information (e.g. email address)
that the backend will use to identify the user.</p>
<p>Note that with this approach, the backend does not have to
take care of all the security and privacy challenges
of properly handling user registration, authentication, etc.
Also, it allows the user to securely reuse an existing account
registered with an established organisation, instead of having
to register yet another account with some web service.</p>
</li>
<li><p>Your openEO script or application acts as
a so called <strong>OpenID Connect client</strong>, with an associated <strong>client ID</strong>.
This practically means that, apart from a user account,
you need a client ID as well (and often a client secret too)
when authenticating.</p>
<p>The details of how to obtain the client ID and secret largely
depend on the backend and OpenID Connect provider:
you might have to register a client yourself,
or you might have to use an existing client ID.
Consult the openEO backend (documentation)
about how to obtain client ID (and secret).</p>
</li>
<li><p>There are several possible “<strong>flows</strong>” (also called “grants”)
to complete the whole OpenID Connect authentication dance:</p>
<ul class="simple">
<li><p>Authorization Code Flow</p></li>
<li><p>Device Flow</p></li>
<li><p>Client Credentials Flow</p></li>
<li><p>Resource Owner Password flow</p></li>
<li><p>Refresh Token Flow</p></li>
</ul>
<p>Picking the right flow highly depends on your use case and context:
are you working interactively,
are you working in a browser based environment,
should your application be able to work
without user interaction in the background,
what does the OpenID Connect provider support,
…?</p>
</li>
</ul>
<p>OpenID Connect is clearly more complex than Basic HTTP Auth.
In the sections below we will discuss the practical details of each flow.</p>
<div class="section" id="general-options">
<h3>General options<a class="headerlink" href="#general-options" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>A backend might support <strong>multiple OpenID Connect providers</strong>.
If there is only one, the openEO Python Client Library will pick it automatically,
but if there are multiple you might get an exception like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OpenEoClientException</span><span class="p">:</span> <span class="n">No</span> <span class="n">provider_id</span> <span class="n">given</span><span class="o">.</span> <span class="n">Available</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;gl&#39;</span><span class="p">,</span> <span class="s1">&#39;ms&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<p>Specify explicitly which provider to use with the <code class="docutils literal notranslate"><span class="pre">provider_id</span></code> argument, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">provider_id</span><span class="o">=</span><span class="s2">&quot;gl&quot;</span><span class="p">,</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="authorization-code-flow">
<h3>Authorization Code Flow<a class="headerlink" href="#authorization-code-flow" title="Permalink to this headline">¶</a></h3>
<p>This is the most popular and widely supported OpenID Connect flow
in the general web development world.
However, it requires an environment that can be hard to get
right when using the openEO Python Client Library in your application:</p>
<ul class="simple">
<li><p>You are working interactively (e.g. in a Jupyter notebook,
in a Python/IPython shell or running a Python script
manually)</p></li>
<li><p>You have access to a web browser
(preferably on the same machine as your application),
to authenticate with the OpenID Connect provider</p></li>
<li><p>That web browser has (network) access
to a temporary web server that will be spawn
by the openEO Python Client Library in your application.</p></li>
<li><p>The URL of the temporary web server is properly whitelisted
in the OpenID client’s “redirect URL” configuration
at the OpenID Connect provider’s side.</p></li>
</ul>
<p>The hardest part are the two last items.
If you just run your application locally on your machine,
the whole procedure is doable (using a <code class="docutils literal notranslate"><span class="pre">localhost</span></code> based web server).
But if you are working remotely
(e.g. on a hosted Jupyter platform),
it can be challenging or even impossible
to get the network access part right.</p>
<div class="section" id="basic-usage">
<h4>Basic usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h4>
<p>The bare essentials to run the authorization code flow:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">(</span>
    <span class="n">client_id</span><span class="o">=</span><span class="n">client_id</span><span class="p">,</span>
    <span class="n">client_secret</span><span class="o">=</span><span class="n">client_secret</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We assume here that you are running this locally
and that the OpenID Connect provider allows to use a wildcard <code class="docutils literal notranslate"><span class="pre">*</span></code>
in the redirect URL whitelist.
The <code class="docutils literal notranslate"><span class="pre">client_id</span></code> and <code class="docutils literal notranslate"><span class="pre">client_secret</span></code> string variables hold
the client ID and secret as discussed above.</p>
<p>What happens when running that <code class="docutils literal notranslate"><span class="pre">authenticate_oidc_authorization_code</span></code> call:</p>
<ul class="simple">
<li><p>the openEO Python Client Library will
try to trigger your browser to open new window,
pointing to a log-in page of the
OpenID Connect provider (e.g. Google or Microsoft).</p></li>
<li><p>You have to authenticate on this page (unless you are logged in already)
and allow the client (identified by <code class="docutils literal notranslate"><span class="pre">client_id</span></code>) access to the
basic account information, such as email address
(unless you already did that).</p></li>
<li><p>Meanwhile, the openEO Python Client Library
is running a short-living webserver in the background
to serve a “redirect URL”.</p></li>
<li><p>When you completed logging in and access granting
on the OpenID Connect provider website,
you are forwarded in your browser to this redirect URL.</p></li>
<li><p>Through the data provided in the request to the redirect URL,
the openEO Python Client Library can obtain the desired
tokens to set up authenticated communication with the backend.</p></li>
</ul>
<p>When the above procedure completed successfully, your connection
is authenticated, and you should be able
to inspect the “user” as seen by the backend, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span><span class="o">.</span><span class="n">describe_account</span><span class="p">()</span>
<span class="go">{&#39;user_id&#39;: &#39;nIrHtS4rhk4ru7531RhtLHXd6Ou0AW3vHfg&#39;}</span>
</pre></div>
</div>
<p>The browser window should show a simple success page
that you can safely close.</p>
</div>
<div class="section" id="options-and-finetuning">
<h4>Options and finetuning<a class="headerlink" href="#options-and-finetuning" title="Permalink to this headline">¶</a></h4>
<p>The above example only covers the bare foundation
of the OpenID Connect Authorization code flow.
In a practical use case, you will probably need
some of the following finetuning options:</p>
<ul>
<li><p>The redirect URL is served by default on <code class="docutils literal notranslate"><span class="pre">localhost</span></code>
with a random port number.
Most OpenID Connect providers however do not support wildcards
in the redirect URL whitelist and require predefined fixed URLs.
Also, your networking situation might require you to use
a different hostname or IP address instead of <code class="docutils literal notranslate"><span class="pre">localhost</span></code>
to reach the short-living webserver.</p>
<p>Both the redirect URL <strong>hostname and port number</strong> can be specified
explicitly with the <cite>server_address</cite> argument, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">server_address</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;myhost.example.com&quot;</span><span class="p">,</span> <span class="mi">40878</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, the corresponding redirect URL to whitelist is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">myhost</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="mi">40878</span><span class="o">/</span><span class="n">callback</span>
</pre></div>
</div>
</li>
<li><p>As noted above, the openEO Python Client Library tries
to trigger your default browser
(on the same machine that your application is running)
to open a new window.
If this does not work
(e.g. you are working remotely in a non-graphical environment),
or you want to use another browser on another machine,
you can specify an alternative way to <strong>“handle” the URL</strong> that initiates
the OpenID Connect flow with the <code class="docutils literal notranslate"><span class="pre">webbrowser_open</span></code> argument.
For example, to just print the URL so you can visit it as you desire:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">webbrowser_open</span><span class="o">=</span><span class="k">lambda</span> <span class="n">url</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Visit this:&quot;</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the web browser you use to visit that URL must be able
to resolve and access the redirect URL
served on the machine where your application is running.</p>
</li>
<li><p>The short-living webserver only waits up to a certain time
for the request to the redirect URL.
During that time, your application is actively waiting
and not doing anything else.
You can increase or decrease the maximum <strong>waiting time</strong> (in seconds)
with the <code class="docutils literal notranslate"><span class="pre">timeout</span></code> argument.</p></li>
</ul>
</div>
</div>
<div class="section" id="device-flow">
<h3>Device Flow<a class="headerlink" href="#device-flow" title="Permalink to this headline">¶</a></h3>
<p>The device flow (also called device authorization grant)
is a relatively new OpenID Connect flow
and it is not as widely supported across different OpenID Connect Providers
as the other flows.
It provides a nice alternative that is roughly comparable
to the authorization code flow but without the previously mentioned issues related
to short-living webservers, network access and browser redirects.</p>
<p>The device flow is only suited for interactive use cases
and requires a web browser for the authentication
with the OpenID Connect provider.
However, it can be any web browser, even one on your mobile phone.
There is no networking magic required to be able to access
any short-living background webserver like with the authorization code flow.</p>
<p>To illustrate the flow, this is how to initiate the authentication:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_device</span><span class="p">(</span>
    <span class="n">client_id</span><span class="o">=</span><span class="n">client_id</span><span class="p">,</span>
    <span class="n">client_secret</span><span class="o">=</span><span class="n">client_secret</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This will print a message like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">To</span> <span class="n">authenticate</span><span class="p">:</span> <span class="n">visit</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">provider</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">device</span>
<span class="ow">and</span> <span class="n">enter</span> <span class="n">the</span> <span class="n">user</span> <span class="n">code</span> <span class="s1">&#39;DTNY-KLNX&#39;</span><span class="o">.</span>
</pre></div>
</div>
<p>You should now visit this URL.
Usually it is intentionally a short URL to make it feasible to type it
instead of copy-pasting it (e.g. on another device).
Authenticate with the OpenID Connect provider and enter the user code
shown in the message.
Meanwhile, the openEO Python Client Library is actively polling the OpenID Connect
provider and when you successfully complete the authentication
and entering of the user code,
it will receive the necessary tokens for authenticated communication
with the backend and print:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Authorized</span> <span class="n">successfully</span><span class="o">.</span>
</pre></div>
</div>
<p>In case of authentication failure, the openEO Python Client Library
will stop polling at some point and raise an exception.</p>
<p>Some additional options for this flow:</p>
<ul>
<li><p>By default, the messages containing the authentication URL, user code
and success message are printed with standard Python <code class="docutils literal notranslate"><span class="pre">print</span></code>.
You can provide a custom function to display them with the <code class="docutils literal notranslate"><span class="pre">display</span></code> option, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_device</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">display</span><span class="o">=</span><span class="k">lambda</span> <span class="n">msg</span><span class="p">:</span> <span class="n">render_popup</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>The openEO Python Client Library waits actively
for successful authentication, so your application is
hanging for a certain time.
You can increate or reduce this maximum polling time (in seconds)
with the <code class="docutils literal notranslate"><span class="pre">max_poll_time</span></code> argument.</p></li>
</ul>
</div>
<div class="section" id="client-credentials-flow">
<h3>Client Credentials Flow<a class="headerlink" href="#client-credentials-flow" title="Permalink to this headline">¶</a></h3>
<p>The Client Credentials flow directly uses the client ID and secret
to authenticate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_client_credentials</span><span class="p">(</span>
    <span class="n">client_id</span><span class="o">=</span><span class="n">client_id</span><span class="p">,</span>
    <span class="n">client_secret</span><span class="o">=</span><span class="n">client_secret</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>It does not involve interactive authentication through a web browser,
which makes it useful for <strong>non-interactive use cases</strong>.</p>
<p>The downside is of the Client Credentials flow is that it can
be challenging or even impossible with a given OpenID Connect provider,
to set up a client that supports this.
Also, your openEO backend might not allow it, because technically
you are authenticating a <em>client</em>, and not a <em>user</em>.</p>
</div>
<div class="section" id="resource-owner-password-flow">
<h3>Resource Owner Password flow<a class="headerlink" href="#resource-owner-password-flow" title="Permalink to this headline">¶</a></h3>
<p>With the Resource Owner Password flow you directly pass
the user (and client) credentials:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_resource_owner_password_credentials</span><span class="p">(</span>
    <span class="n">client_id</span><span class="o">=</span><span class="n">client_id</span><span class="p">,</span>
    <span class="n">client_secret</span><span class="o">=</span><span class="n">client_secret</span><span class="p">,</span>
    <span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">,</span>
    <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Like the Client Credentials flow, it is useful for <strong>non-interactive uses cases</strong>.</p>
<p>However, usage of the Resource Owner Password flow is <strong>generally discouraged</strong>
because of its poor security features (e.g. OAuth/OIDC was designed
to avoid passing and storing user passwords unnecessarily).
It is also not widely supported across OpenID Connect providers,
probably due to its weak security measures.</p>
</div>
<div class="section" id="refresh-token-flow">
<h3>Refresh Token Flow<a class="headerlink" href="#refresh-token-flow" title="Permalink to this headline">¶</a></h3>
<p>When OpenID Connect authentication completes successfully,
the openID Python library receives an access token
to be used when doing authenticated calls to the backend.
The access token usually has a short lifetime to reduce
the security risk when it would be stolen or intercepted.
The openID Python library also receives a <em>refresh token</em>
that can be used, through the Refresh Token flow,
to easily request a new access token,
without having to re-authenticate,
which makes it useful for <strong>non-interactive uses cases</strong>.</p>
<p>However, as it needs an existing refresh token,
the Refresh Token Flow requires
<strong>first to authenticate with one of the other flows</strong>
(but in practice this should not be done very often
because refresh tokens usually have a relatively long lifetime).
When doing the initial authentication,
you have to explicitly enable storage of the refresh token,
through the <code class="docutils literal notranslate"><span class="pre">store_refresh_token</span></code> argument, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">(</span>
    <span class="o">...</span>
    <span class="n">store_refresh_token</span><span class="o">=</span><span class="kc">True</span>
</pre></div>
</div>
<p>The refresh token will be stored in file in private file
in your home directory and will be used automatically
when authenticating with the Refresh Token Flow like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_refresh_token</span><span class="p">(</span>
    <span class="n">client_secret</span><span class="o">=</span><span class="n">client_secret</span><span class="p">,</span>
    <span class="n">client_id</span><span class="o">=</span><span class="n">client_id</span>
<span class="p">)</span>
</pre></div>
</div>
<p>You can also bootstrap the refresh token file
as described in <a class="reference internal" href="#oidc-auth-get-refresh-token"><span class="std std-ref">OpenID Connect refresh tokens</span></a></p>
</div>
</div>
<div class="section" id="config-files-and-openeo-auth-helper-tool">
<h2>Config files and <code class="docutils literal notranslate"><span class="pre">openeo-auth</span></code> helper tool<a class="headerlink" href="#config-files-and-openeo-auth-helper-tool" title="Permalink to this headline">¶</a></h2>
<p>The openEO Python Client Library provides some features and tools
that ease the usability and security challenges
that come with authentication (especially in case of OpenID Connect).</p>
<p>Note that the code examples above contain quite some <strong>passwords and other secrets</strong>
that should be kept safe from prying eyes.
It is bad practice to define these kind of secrets directly
in your scripts and source code because that makes it quite hard
to responsibly share or reuse your code.
Even worse is storing these secrets in your version control system,
where it might be near impossible to remove them again.
A better solution is to keep <strong>secrets in separate config files</strong>,
outside of your normal source code tree
(to avoid committing them accidentally).</p>
<p>The openEO Python Client Library supports config files to store:
user names, passwords, client IDs, client secrets, etc,
so you don’t have to specify them always in your scripts and applications.</p>
<p>The openEO Python Client Library (when installed properly)
provides a command line tool <code class="docutils literal notranslate"><span class="pre">openeo-auth</span></code> to bootstrap and manage
these configs and secrets.
It is a command line tool that provides various “subcommands”
and has built-in help:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth -h
usage: openeo-auth [-h] [--verbose]
                   {paths,config-dump,token-dump,add-basic,add-oidc,oidc-auth}
                   ...

Tool to manage openEO related authentication and configuration.

optional arguments:
  -h, --help            show this help message and exit

Subcommands:
  {paths,config-dump,token-dump,add-basic,add-oidc,oidc-auth}
    paths               Show paths to config/token files.
    config-dump         Dump config file.
...
</pre></div>
</div>
<p>For example, to see the expected paths of the config files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth paths
openEO auth config: /home/john/.config/openeo-python-client/auth-config.json (perms: 0o600, size: 1414B)
openEO OpenID Connect refresh token store: /home/john/.local/share/openeo-python-client/refresh-tokens.json (perms: 0o600, size: 846B)
</pre></div>
</div>
<p>With the <code class="docutils literal notranslate"><span class="pre">config-dump</span></code> and <code class="docutils literal notranslate"><span class="pre">token-dump</span></code> subcommands you can dump
the current configuration and stored refresh tokens, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth config-dump
### /home/john/.config/openeo-python-client/auth-config.json ###############
{
  &quot;backends&quot;: {
    &quot;https://openeo.example.com&quot;: {
      &quot;basic&quot;: {
        &quot;username&quot;: &quot;john&quot;,
        &quot;password&quot;: &quot;&lt;redacted&gt;&quot;,
        &quot;date&quot;: &quot;2020-07-24T13:40:50Z&quot;
...
</pre></div>
</div>
<p>The sensible information (like passwords) are redacted by default.</p>
<div class="section" id="basic-http-auth-config">
<h3>Basic HTTP Auth config<a class="headerlink" href="#basic-http-auth-config" title="Permalink to this headline">¶</a></h3>
<p>With the <code class="docutils literal notranslate"><span class="pre">add-basic</span></code> subcommand you can add Basic HTTP Auth credentials
for a given backend to the config.
It will interactively ask for username and password and
try if these credentials work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth add-basic https://openeo.example.com/
Enter username and press enter: john
Enter password and press enter:
Trying to authenticate with &#39;https://openeo.example.com&#39;
Successfully authenticated &#39;john&#39;
Saved credentials to &#39;/home/john/.config/openeo-python-client/auth-config.json&#39;
</pre></div>
</div>
<p>Now you can authenticate in your application without having to
specify username and password explicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_basic</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="openid-connect-configs">
<h3>OpenID Connect configs<a class="headerlink" href="#openid-connect-configs" title="Permalink to this headline">¶</a></h3>
<p>Likewise, with the <code class="docutils literal notranslate"><span class="pre">add-oidc</span></code> subcommand you can add OpenID Connect
credentials to the config:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth add-oidc https://openeo.example.com/
Using provider ID &#39;example&#39; (issuer &#39;https://oidc.example.com/&#39;)
Enter client_id and press enter: client-d7393fba
Enter client_secret and press enter:
Saved client information to &#39;/home/john/.config/openeo-python-client/auth-config.json&#39;
</pre></div>
</div>
<p>Now you can user OpenID Connect based authentication in your application
without having to specify the client ID and client secret explicitly,
like one of these calls:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_authorization_code</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_client_credentials</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_resource_owner_password_credentials</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_device</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">authenticate_oidc_refresh_token</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that you still have to add additional options as required, like
<code class="docutils literal notranslate"><span class="pre">provider_id</span></code>, <code class="docutils literal notranslate"><span class="pre">server_address</span></code>, <code class="docutils literal notranslate"><span class="pre">store_refresh_token</span></code>, etc.</p>
<div class="section" id="openid-connect-refresh-tokens">
<span id="oidc-auth-get-refresh-token"></span><h4>OpenID Connect refresh tokens<a class="headerlink" href="#openid-connect-refresh-tokens" title="Permalink to this headline">¶</a></h4>
<p>There is also a <code class="docutils literal notranslate"><span class="pre">oidc-auth</span></code> subcommand to execute an OpenID Connect
authentication flow and store the resulting refresh token.
This is intended to for bootstrapping the environment or system
on which you want to run openEO scripts or applications that use
the Refresh Token Flow for authentication.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ openeo-auth oidc-auth https://openeo.example.com
Using config &#39;/home/john/.config/openeo-python-client/auth-config.json&#39;.
Which OpenID Connect flow should be used? (Note: some options might not be supported by the provider.)
[1] Authorization code flow
[2] Device flow
Choose one (enter index): 1
Starting OpenID Connect authorization code flow:
a browser window should open allowing you to log in with the identity provider
and grant access to the client &#39;openeo-dev&#39; (timeout: 60s).
The OpenID Connect authorization code flow was successful.
Stored refresh token in &#39;/home/john/.local/share/openeo-python-client/refresh-tokens.json&#39;
</pre></div>
</div>
</div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2017 - 2021, Jeroen Dries.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/auth.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/Open-EO/openeo-python-client" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>