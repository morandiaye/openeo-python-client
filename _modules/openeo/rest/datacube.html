
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>openeo.rest.datacube &#8212; openEO Python Client 0.6.2a1 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">openEO Python Client</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Open-EO&repo=openeo-python-client&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/Open-EO/openeo-python-client">
    <img
        alt="https://secure.travis-ci.org/Open-EO/openeo-python-client.svg?branch=master"
        src="https://secure.travis-ci.org/Open-EO/openeo-python-client.svg?branch=master"
    />
</a>
</p>


<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script><!-- Alabaster (krTheme++) Hacks -->

<div class="sidebar-meta">
<h3>Meta</h3>
<div>Docs for openEO Python Client</div>
<div>Version: <code>0.6.2a1</code></div>
<div>Last updated: 2021/04/01</div>
</div>

<!-- CSS Adjustments from requests: https://github.com/kennethreitz/requests/blob/master/docs/_templates/hacks.html -->
<style type="text/css">
  /* Rezzy requires precise alignment. */
  img.logo {margin-left: -20px!important;}
  /* "Quick Search" should be capitalized. */
  div#searchbox h3 {text-transform: capitalize;}
  /* Make the document a little wider, less code is cut-off. */
  div.document {width: 1008px;}
  /* Much-improved spacing around code blocks. */
  div.highlight pre {padding: 11px 14px;}
  /* Remain Responsive! */
  @media screen and (max-width: 1008px) {
    div.sphinxsidebar {display: none;}
    div.document {width: 100%!important;}
    /* Have code blocks escape the document right-margin. */
    div.highlight pre {margin-right: -30px;}
  }

  /* Reduce space between paragraphs for better visual structure */
  p { margin: 1ex 0; }

  /* Hide "view source code" links by default, only show on hover */
  dt .viewcode-link { visibility: hidden; font-size: 70%; }
  dt:hover .viewcode-link { visibility: visible; }

  /* More breathing space between successive methods */
  dl { margin-bottom: 1.5em; }

  dl.field-list > dt {
      /* Cleaner aligning of Parameters/Returns/Raises listing with method description paragraphs */
      padding-left: 0;
      /* Make Parameters/Returns/Raises labels less dominant */
      text-transform: uppercase;
      font-size: 70%;
  }

  .sidebar-meta {
      font-size: 80%;
  }

</style>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for openeo.rest.datacube</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The main module for creating earth observation processes. It aims to easily build complex process chains, that can</span>
<span class="sd">be evaluated by an openEO backend.</span>

<span class="sd">.. data:: THIS</span>

<span class="sd">    Symbolic reference to the current data cube, to be used as argument in DataCube.process() calls</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">staticmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span>
<span class="kn">import</span> <span class="nn">shapely.geometry.base</span>
<span class="kn">from</span> <span class="nn">deprecated</span> <span class="kn">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">mapping</span>

<span class="kn">import</span> <span class="nn">openeo</span>
<span class="kn">import</span> <span class="nn">openeo.processes</span>
<span class="kn">from</span> <span class="nn">openeo.api.process</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">openeo.imagecollection</span> <span class="kn">import</span> <span class="n">ImageCollection</span>
<span class="kn">from</span> <span class="nn">openeo.internal.graph_building</span> <span class="kn">import</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">ReduceNode</span>
<span class="kn">from</span> <span class="nn">openeo.metadata</span> <span class="kn">import</span> <span class="n">CollectionMetadata</span><span class="p">,</span> <span class="n">Band</span><span class="p">,</span> <span class="n">BandDimension</span>
<span class="kn">from</span> <span class="nn">openeo.processes</span> <span class="kn">import</span> <span class="n">ProcessBuilder</span>
<span class="kn">from</span> <span class="nn">openeo.rest</span> <span class="kn">import</span> <span class="n">BandMathException</span><span class="p">,</span> <span class="n">OperatorException</span><span class="p">,</span> <span class="n">OpenEoClientException</span>
<span class="kn">from</span> <span class="nn">openeo.rest.job</span> <span class="kn">import</span> <span class="n">RESTJob</span>
<span class="kn">from</span> <span class="nn">openeo.rest.udp</span> <span class="kn">import</span> <span class="n">RESTUserDefinedProcess</span>
<span class="kn">from</span> <span class="nn">openeo.rest.vectorcube</span> <span class="kn">import</span> <span class="n">VectorCube</span>
<span class="kn">from</span> <span class="nn">openeo.util</span> <span class="kn">import</span> <span class="n">get_temporal_extent</span><span class="p">,</span> <span class="n">dict_no_none</span><span class="p">,</span> <span class="n">legacy_alias</span><span class="p">,</span> <span class="n">rfc3339</span>


<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typing</span><span class="p">,</span> <span class="s1">&#39;TYPE_CHECKING&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="c1"># Only import this for type hinting purposes. Runtime import causes circular dependency issues.</span>
    <span class="c1"># Note: the `hasattr` check is necessary for Python versions before 3.5.2.</span>
    <span class="kn">from</span> <span class="nn">openeo.rest.connection</span> <span class="kn">import</span> <span class="n">Connection</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># Sentinel object to refer to &quot;current&quot; cube in chained cube processing expressions.</span>
<span class="n">THIS</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<div class="viewcode-block" id="DataCube"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube">[docs]</a><span class="k">class</span> <span class="nc">DataCube</span><span class="p">(</span><span class="n">ImageCollection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class representing a openEO Data Cube. Data loaded from the backend is returned as an object of this class.</span>
<span class="sd">    Various processing methods can be invoked to build a complete workflow.</span>

<span class="sd">    Supports openEO API 1.0.</span>
<span class="sd">    In earlier versions this was called `ImageCollectionClient`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">connection</span><span class="p">:</span> <span class="s1">&#39;openeo.Connection&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">CollectionMetadata</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Process graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pg</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">connection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">CollectionMetadata</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;DataCube(</span><span class="si">{pg}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_pg</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the process graph in flat dict representation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">()</span>

<div class="viewcode-block" id="DataCube.flat_graph"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.flat_graph">[docs]</a>    <span class="k">def</span> <span class="nf">flat_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the process graph in flat dict representation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pg</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">()</span></div>

    <span class="n">flatten</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">flat_graph</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;flatten&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.to_json"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">separators</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get JSON representation of (flat dict) process graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;process_graph&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pg</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">,</span> <span class="n">separators</span><span class="o">=</span><span class="n">separators</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_api_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">capabilities</span><span class="p">()</span><span class="o">.</span><span class="n">api_version_check</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">connection</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;openeo.Connection&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span>

<div class="viewcode-block" id="DataCube.process"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">process_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CollectionMetadata</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">namespace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic helper to create a new DataCube by applying a process.</span>

<span class="sd">        :param process_id: process id of the process.</span>
<span class="sd">        :param arguments: argument dictionary for the process.</span>
<span class="sd">        :param metadata: optional: metadata to override original cube metadata (e.g. when reducing dimensions)</span>
<span class="sd">        :param namespace: optional: process namespace</span>
<span class="sd">        :return: new DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="p">(</span><span class="n">arguments</span> <span class="ow">or</span> <span class="p">{}),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DataCube</span><span class="p">):</span>
                <span class="n">arguments</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;from_node&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">_pg</span><span class="p">}</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="ow">is</span> <span class="n">THIS</span><span class="p">:</span>
                <span class="n">arguments</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;from_node&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pg</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="n">process_id</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">,</span>
            <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
        <span class="p">),</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span></div>

    <span class="n">graph_add_node</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="s2">&quot;graph_add_node&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.process_with_node"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.process_with_node">[docs]</a>    <span class="k">def</span> <span class="nf">process_with_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pg</span><span class="p">:</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CollectionMetadata</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic helper to create a new DataCube by applying a process (given as process graph node)</span>

<span class="sd">        :param pg: process graph node (containing process id and arguments)</span>
<span class="sd">        :param metadata: optional: metadata to override original cube metadata (e.g. when reducing dimensions)</span>
<span class="sd">        :return: new DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: deep copy `self.metadata` instead of using same instance?</span>
        <span class="c1"># TODO: cover more cases where metadata has to be altered</span>
        <span class="k">return</span> <span class="n">DataCube</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">pg</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.load_collection"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.load_collection">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_collection</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="n">collection_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">connection</span><span class="p">:</span> <span class="s1">&#39;openeo.Connection&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">spatial_extent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">temporal_extent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">bands</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">fetch_metadata</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">properties</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Raster Data cube.</span>

<span class="sd">        :param collection_id: image collection identifier</span>
<span class="sd">        :param connection: The connection to use to connect with the backend.</span>
<span class="sd">        :param spatial_extent: limit data to specified bounding box or polygons</span>
<span class="sd">        :param temporal_extent: limit data to specified temporal interval</span>
<span class="sd">        :param bands: only add the specified bands</span>
<span class="sd">        :param properties: limit data by metadata property predicates</span>
<span class="sd">        :return: new DataCube containing the collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">temporal_extent</span><span class="p">:</span>
            <span class="n">temporal_extent</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_temporal_extent</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="n">temporal_extent</span><span class="p">)</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">collection_id</span><span class="p">,</span>
            <span class="s1">&#39;spatial_extent&#39;</span><span class="p">:</span> <span class="n">spatial_extent</span><span class="p">,</span>
            <span class="s1">&#39;temporal_extent&#39;</span><span class="p">:</span> <span class="n">temporal_extent</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collection_id</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="n">fetch_metadata</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">collection_metadata</span><span class="p">(</span><span class="n">collection_id</span><span class="p">)</span> <span class="k">if</span> <span class="n">fetch_metadata</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">bands</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">bands</span> <span class="o">=</span> <span class="p">[</span><span class="n">bands</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">metadata</span><span class="p">:</span>
                <span class="n">bands</span> <span class="o">=</span> <span class="p">[</span> <span class="n">b</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">metadata</span><span class="o">.</span><span class="n">band_dimension</span><span class="o">.</span><span class="n">band_name</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">filter_bands</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Ensure minimal metadata with best effort band dimension guess (based on `bands` argument).</span>
                <span class="n">band_dimension</span> <span class="o">=</span> <span class="n">BandDimension</span><span class="p">(</span><span class="s2">&quot;bands&quot;</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="p">[</span><span class="n">Band</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">])</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">CollectionMetadata</span><span class="p">({},</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="n">band_dimension</span><span class="p">])</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;bands&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bands</span>
        <span class="k">if</span> <span class="n">properties</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">prop</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">prop</span><span class="p">,</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;load_collection&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">pg</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span></div>

    <span class="n">create_collection</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">load_collection</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;create_collection&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.load_disk_collection"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.load_disk_collection">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_disk_collection</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">connection</span><span class="p">:</span> <span class="s1">&#39;openeo.Connection&#39;</span><span class="p">,</span> <span class="n">file_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">glob_pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">options</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads image data from disk as a DataCube.</span>

<span class="sd">        :param connection: The connection to use to connect with the backend.</span>
<span class="sd">        :param file_format: the file format, e.g. &#39;GTiff&#39;</span>
<span class="sd">        :param glob_pattern: a glob pattern that matches the files to load from disk</span>
<span class="sd">        :param options: options specific to the file format</span>
<span class="sd">        :return: the data as a DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;load_disk_data&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;format&#39;</span><span class="p">:</span> <span class="n">file_format</span><span class="p">,</span>
                <span class="s1">&#39;glob_pattern&#39;</span><span class="p">:</span> <span class="n">glob_pattern</span><span class="p">,</span>
                <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="n">options</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">pg</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">CollectionMetadata</span><span class="p">({}))</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_temporal_extent</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">start_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">end_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">extent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]],</span> <span class="n">Parameter</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parameter aware temporal_extent normalizer&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">extent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">get_temporal_extent</span><span class="p">(</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
                <span class="n">convertor</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span> <span class="k">else</span> <span class="n">rfc3339</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="p">))</span>


<div class="viewcode-block" id="DataCube.filter_temporal"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.filter_temporal">[docs]</a>    <span class="k">def</span> <span class="nf">filter_temporal</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">start_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">end_date</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">extent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Limit the DataCube to a certain date range, which can be specified in several ways:</span>

<span class="sd">        &gt;&gt;&gt; im.filter_temporal(&quot;2019-07-01&quot;, &quot;2019-08-01&quot;)</span>
<span class="sd">        &gt;&gt;&gt; im.filter_temporal([&quot;2019-07-01&quot;, &quot;2019-08-01&quot;])</span>
<span class="sd">        &gt;&gt;&gt; im.filter_temporal(extent=[&quot;2019-07-01&quot;, &quot;2019-08-01&quot;])</span>
<span class="sd">        &gt;&gt;&gt; im.filter_temporal(start_date=&quot;2019-07-01&quot;, end_date=&quot;2019-08-01&quot;])</span>

<span class="sd">        :param start_date: start date of the filter (inclusive), as a string or date object</span>
<span class="sd">        :param end_date: end date of the filter (exclusive), as a string or date object</span>
<span class="sd">        :param extent: two element list/tuple start and end date of the filter</span>
<span class="sd">        :return: An ImageCollection filtered by date.</span>

<span class="sd">        https://open-eo.github.io/openeo-api/processreference/#filter_temporal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;filter_temporal&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
                <span class="s1">&#39;extent&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_temporal_extent</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.filter_bbox"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.filter_bbox">[docs]</a>    <span class="k">def</span> <span class="nf">filter_bbox</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">west</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">south</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">east</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">north</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">bbox</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Limits the data cube to the specified bounding box.</span>

<span class="sd">        The bounding box can be specified in multiple ways.</span>

<span class="sd">            - With keyword arguments::</span>

<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(west=3, south=51, east=4, north=52, crs=4326)</span>

<span class="sd">            - With a (west, south, east, north) list or tuple::</span>

<span class="sd">                &gt;&gt;&gt; cube.filter_bbox([3, 51, 4, 52])</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox=[3, 51, 4, 52])</span>

<span class="sd">            - With a bbox dictionary::</span>

<span class="sd">                &gt;&gt;&gt; bbox = {&quot;west&quot;: 3, &quot;south&quot;: 51, &quot;east&quot;: 4, &quot;north&quot;: 52, &quot;crs&quot;: 4326}</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox)</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox=bbox)</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(**bbox)</span>

<span class="sd">            - With a shapely geometry (of which the bounding box will be used)::</span>

<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(geometry)</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox=geometry)</span>

<span class="sd">            - Passing a parameter::</span>

<span class="sd">                &gt;&gt;&gt; bbox_param = Parameter(name=&quot;my_bbox&quot;, schema=&quot;object&quot;)</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox_param)</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(bbox=bbox_param)</span>

<span class="sd">            - Deprecated: positional arguments are also supported,</span>
<span class="sd">              but follow a non-standard order for legacy reasons::</span>

<span class="sd">                &gt;&gt;&gt; west, east, north, south = 3, 4, 52, 51</span>
<span class="sd">                &gt;&gt;&gt; cube.filter_bbox(west, east, north, south)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span><span class="p">,</span> <span class="n">bbox</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t mix positional arguments with keyword arguments.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bbox</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t mix `bbox` with `west`/`south`/`east`/`north` keyword arguments.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">4</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
                <span class="c1"># Handle old-style west-east-north-south order</span>
                <span class="c1"># TODO remove handling of this legacy order?</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Deprecated argument order usage: `filter_bbox(west, east, north, south)`.&quot;</span>
                              <span class="s2">&quot; Use keyword arguments or tuple/list argument instead.&quot;</span><span class="p">)</span>
                <span class="n">west</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">crs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">4</span>
                                     <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">))):</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bbox</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">):</span>
                    <span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">.</span><span class="n">bounds</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">west</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">north</span> <span class="o">=</span> <span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;west&quot;</span><span class="p">,</span> <span class="s2">&quot;south&quot;</span><span class="p">,</span> <span class="s2">&quot;east&quot;</span><span class="p">,</span> <span class="s2">&quot;north&quot;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="s2">&quot;crs&quot;</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">:</span>
                        <span class="n">crs</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="s2">&quot;crs&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>

            <span class="n">extent</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;west&#39;</span><span class="p">:</span> <span class="n">west</span><span class="p">,</span> <span class="s1">&#39;east&#39;</span><span class="p">:</span> <span class="n">east</span><span class="p">,</span> <span class="s1">&#39;north&#39;</span><span class="p">:</span> <span class="n">north</span><span class="p">,</span> <span class="s1">&#39;south&#39;</span><span class="p">:</span> <span class="n">south</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">crs</span><span class="p">:</span>
                <span class="n">extent</span><span class="p">[</span><span class="s2">&quot;crs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">crs</span>
            <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extent</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;filter_bbox&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
                <span class="s1">&#39;extent&#39;</span><span class="p">:</span> <span class="n">extent</span>
            <span class="p">}</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.filter_bands"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.filter_bands">[docs]</a>    <span class="k">def</span> <span class="nf">filter_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter the data cube by the given bands</span>

<span class="sd">        :param bands: list of band names, common names or band indices. Single band name can also be given as string.</span>
<span class="sd">        :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="p">[</span><span class="n">bands</span><span class="p">]</span>
        <span class="n">bands</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">band_dimension</span><span class="o">.</span><span class="n">band_name</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;filter_bands&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span> <span class="s1">&#39;bands&#39;</span><span class="p">:</span> <span class="n">bands</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">cube</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
            <span class="n">cube</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">filter_bands</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cube</span></div>

    <span class="n">band_filter</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">filter_bands</span><span class="p">,</span> <span class="s2">&quot;band_filter&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.band"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.band">[docs]</a>    <span class="k">def</span> <span class="nf">band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter out a single band</span>

<span class="sd">        :param band: band name, band common name or band index.</span>
<span class="sd">        :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">band_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">get_band_index</span><span class="p">(</span><span class="n">band</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_bands</span><span class="p">(</span><span class="n">reducer</span><span class="o">=</span><span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;array_element&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;from_parameter&#39;</span><span class="p">:</span> <span class="s1">&#39;data&#39;</span><span class="p">},</span>
                <span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">band_index</span>
            <span class="p">},</span>
        <span class="p">))</span></div>

<div class="viewcode-block" id="DataCube.resample_spatial"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.resample_spatial">[docs]</a>    <span class="k">def</span> <span class="nf">resample_spatial</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">projection</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;near&#39;</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;upper-left&#39;</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;resample_spatial&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;resolution&#39;</span><span class="p">:</span> <span class="n">resolution</span><span class="p">,</span>
            <span class="s1">&#39;projection&#39;</span><span class="p">:</span> <span class="n">projection</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;align&#39;</span><span class="p">:</span> <span class="n">align</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.resample_cube_spatial"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.resample_cube_spatial">[docs]</a>    <span class="k">def</span> <span class="nf">resample_cube_spatial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span> <span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;near&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;resample_cube_spatial&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;from_node&#39;</span><span class="p">:</span> <span class="n">target</span><span class="o">.</span><span class="n">_pg</span><span class="p">},</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span>
        <span class="p">})</span></div>

    <span class="k">def</span> <span class="nf">_operator_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Generic handling of (mathematical) binary operator&quot;&quot;&quot;</span>
        <span class="n">band_math_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_bandmath_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">band_math_mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandmath_operator_binary_scalar</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataCube</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandmath_operator_binary_cubes</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataCube</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_operator_binary_cubes</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="c1"># TODO #123: support appending to pre-existing apply process instead of adding a whole new one</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">process</span><span class="o">=</span><span class="n">PGNode</span><span class="p">(</span>
                    <span class="n">process_id</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
                    <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">},</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">other</span><span class="p">}</span>
                <span class="p">))</span>
        <span class="k">raise</span> <span class="n">OperatorException</span><span class="p">(</span><span class="s2">&quot;Unsupported operator </span><span class="si">{op!r}</span><span class="s2"> with </span><span class="si">{other!r}</span><span class="s2"> (band math mode=</span><span class="si">{b}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">band_math_mode</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_operator_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="n">band_math_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_bandmath_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">band_math_mode</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bandmath_operator_unary</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">OperatorException</span><span class="p">(</span><span class="s2">&quot;Unsupported unary operator </span><span class="si">{op!r}</span><span class="s2"> (band math mode=</span><span class="si">{b}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">band_math_mode</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;subtract&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;divide&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;multiply&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">normalized_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="c1"># This DataCube method is only a convenience function when in band math mode</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_bandmath_mode</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">other</span><span class="o">.</span><span class="n">_in_bandmath_mode</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;normalized_difference&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.logical_or"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.logical_or">[docs]</a>    <span class="k">def</span> <span class="nf">logical_or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply element-wise logical `or` operation</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return: logical_or(this, other)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.logical_and"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.logical_and">[docs]</a>    <span class="k">def</span> <span class="nf">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply element-wise logical `and` operation</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return: logical_and(this, other)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_unary</span><span class="p">(</span><span class="s2">&quot;not&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;neq&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pixelwise comparison of this data cube with another cube or constant.</span>

<span class="sd">        :param other: Another data cube, or a constant</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;eq&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pairwise comparison of the bands in this data cube with the bands in the &#39;other&#39; data cube.</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return: this &gt; other</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;gt&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;gte&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pairwise comparison of the bands in this data cube with the bands in the &#39;other&#39; data cube.</span>
<span class="sd">        The number of bands in both data cubes has to be the same.</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return: this &lt; other</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_binary</span><span class="p">(</span><span class="s2">&quot;lte&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">reverse</span><span class="p">):</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="s2">&quot;power&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bandmath_node</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;from_node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">reducer_process_graph</span><span class="p">()}</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">clone_with_new_reducer</span><span class="p">(</span>
            <span class="n">PGNode</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="p">))</span>

    <span class="k">def</span> <span class="nf">ln</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_unary</span><span class="p">(</span><span class="s2">&quot;ln&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">logarithm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator_unary</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">log2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logarithm</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logarithm</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bandmath_operator_binary_cubes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">,</span>
                                        <span class="n">left_arg_name</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">right_arg_name</span><span class="o">=</span><span class="s2">&quot;y&quot;</span>
                                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Band math binary operator with cube as right hand side argument&quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bandmath_node</span><span class="p">()</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_bandmath_node</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">BandMathException</span><span class="p">(</span><span class="s2">&quot;&#39;Band math&#39; between bands of different data cubes is not supported yet.&quot;</span><span class="p">)</span>

        <span class="c1"># Build reducer&#39;s sub-processgraph</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="n">left_arg_name</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_node&quot;</span><span class="p">:</span> <span class="n">left</span><span class="o">.</span><span class="n">reducer_process_graph</span><span class="p">()},</span>
                <span class="n">right_arg_name</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_node&quot;</span><span class="p">:</span> <span class="n">right</span><span class="o">.</span><span class="n">reducer_process_graph</span><span class="p">()},</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">clone_with_new_reducer</span><span class="p">(</span><span class="n">merged</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_bandmath_operator_binary_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Band math binary operator with scalar value (int or float) as right hand side argument&quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bandmath_node</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;from_node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">reducer_process_graph</span><span class="p">()}</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">clone_with_new_reducer</span><span class="p">(</span>
            <span class="n">PGNode</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="p">))</span>

    <span class="k">def</span> <span class="nf">_bandmath_operator_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bandmath_node</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">clone_with_new_reducer</span><span class="p">(</span>
            <span class="n">PGNode</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;from_node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">reducer_process_graph</span><span class="p">()},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="p">))</span>

    <span class="k">def</span> <span class="nf">_in_bandmath_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># TODO #123 is it (still) necessary to make &quot;band&quot; math a special case?</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pg</span><span class="p">,</span> <span class="n">ReduceNode</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pg</span><span class="o">.</span><span class="n">band_math_mode</span>

    <span class="k">def</span> <span class="nf">_get_bandmath_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ReduceNode</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check we are in bandmath mode and return the node&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_bandmath_mode</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">BandMathException</span><span class="p">(</span><span class="s2">&quot;Must be in band math mode already&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pg</span>

    <span class="k">def</span> <span class="nf">_merge_operator_binary_cubes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="n">left_arg_name</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
                                     <span class="n">right_arg_name</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Merge two cubes with given operator as overlap_resolver.&quot;&quot;&quot;</span>
        <span class="c1"># TODO #123 reuse an existing merge_cubes process graph if it already exists?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_cubes</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">overlap_resolver</span><span class="o">=</span><span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="n">left_arg_name</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">},</span>
                <span class="n">right_arg_name</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;y&quot;</span><span class="p">},</span>
            <span class="p">}</span>
        <span class="p">))</span>

<div class="viewcode-block" id="DataCube.aggregate_spatial"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.aggregate_spatial">[docs]</a>    <span class="k">def</span> <span class="nf">aggregate_spatial</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">geometries</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">],</span>
            <span class="n">reducer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Aggregates statistics for one or more geometries (e.g. zonal statistics for polygons)</span>
<span class="sd">        over the spatial dimensions.</span>

<span class="sd">        :param geometries: shapely geometry, GeoJSON dictionary or path to GeoJSON file</span>
<span class="sd">        :param reducer: a callback function that creates a process graph, see :ref:`callbackfunctions`</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO #125 arguments: target dimension, context</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometries</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">)):</span>
            <span class="c1"># polygon is a path to vector file</span>
            <span class="c1"># TODO this is non-standard process: check capabilities? #104 #40. Load polygon client side otherwise</span>
            <span class="n">geometries</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;read_vector&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">geometries</span><span class="p">)})</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometries</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">):</span>
            <span class="n">geometries</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">(</span><span class="n">geometries</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometries</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">geometries</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="c1"># TODO: support more geometry types?</span>
                <span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">,</span> <span class="s2">&quot;GeometryCollection&quot;</span><span class="p">,</span> <span class="s1">&#39;FeatureCollection&#39;</span>
        <span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpenEoClientException</span><span class="p">(</span><span class="s2">&quot;Invalid `geometries`: </span><span class="si">{g!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="n">geometries</span><span class="p">))</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;aggregate_spatial&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span> <span class="n">geometries</span><span class="o">=</span><span class="n">geometries</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="n">reducer</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.zonal_statistics"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.zonal_statistics">[docs]</a>    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">reason</span><span class="o">=</span><span class="s2">&quot;use aggregate_spatial instead&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">zonal_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="s2">&quot;day&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates statistics for each zone specified in a file.</span>

<span class="sd">        :param regions: GeoJSON or a path to a GeoJSON file containing the</span>
<span class="sd">                        regions. For paths you must specify the path to a</span>
<span class="sd">                        user-uploaded file without the user id in the path.</span>
<span class="sd">        :param func: Statistical function to calculate for the specified</span>
<span class="sd">                     zones. example values: min, max, mean, median, mode</span>
<span class="sd">        :param scale: A nominal scale in meters of the projection to work</span>
<span class="sd">                      in. Defaults to 1000.</span>
<span class="sd">        :param interval: Interval to group the time series. Allowed values:</span>
<span class="sd">                        day, wee, month, year. Defaults to day.</span>

<span class="sd">        :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">regions_geojson</span> <span class="o">=</span> <span class="n">regions</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
            <span class="n">regions_geojson</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
        <span class="n">process_id</span> <span class="o">=</span> <span class="s1">&#39;zonal_statistics&#39;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;regions&#39;</span><span class="p">:</span> <span class="n">regions_geojson</span><span class="p">,</span>
            <span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">func</span><span class="p">,</span>
            <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">scale</span><span class="p">,</span>
            <span class="s1">&#39;interval&#39;</span><span class="p">:</span> <span class="n">interval</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_callback</span><span class="p">(</span><span class="n">process</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span> <span class="n">parent_parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a &quot;callback&quot; process: a user defined process that is used by another process (such</span>
<span class="sd">        as `apply`, `apply_dimension`, `reduce`, ....)</span>

<span class="sd">        :param process: process id string, PGNode or callable that uses the ProcessBuilder mechanism to build a process</span>
<span class="sd">        :parameter parameter_mapping: mapping of child (callback) parameters names to parent process parameter names</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_parameter_names</span><span class="p">(</span><span class="n">process</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="c1"># TODO: autodetect the parameters defined by process?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">):</span>
            <span class="c1"># Assume this is already a valid callback process</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="n">process</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Assume given reducer is a simple predefined reduce process_id</span>
            <span class="k">if</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">openeo</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="n">process_params</span> <span class="o">=</span> <span class="n">get_parameter_names</span><span class="p">(</span><span class="n">openeo</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">process</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Best effort guess</span>
                <span class="n">process_params</span> <span class="o">=</span> <span class="n">parent_parameters</span>
            <span class="k">if</span> <span class="n">parent_parameters</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">process_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">process_params</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]):</span>
                <span class="c1"># Special case: wrap all parent parameters in an array</span>
                <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span><span class="n">process_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">[{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parent_parameters</span><span class="p">]}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="n">b</span><span class="p">}</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">process_params</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="p">)}</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="n">PGNode</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="n">process</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
            <span class="n">process_params</span> <span class="o">=</span> <span class="n">get_parameter_names</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent_parameters</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">process_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">process_params</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]):</span>
                <span class="c1"># Special case: wrap all parent parameters in an array</span>
                <span class="n">arguments</span> <span class="o">=</span> <span class="p">[</span><span class="n">ProcessBuilder</span><span class="p">([{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parent_parameters</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arguments</span> <span class="o">=</span> <span class="p">[</span><span class="n">ProcessBuilder</span><span class="p">({</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">})</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parent_parameters</span><span class="p">]</span>

            <span class="n">pg</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="o">*</span><span class="n">arguments</span><span class="p">)</span><span class="o">.</span><span class="n">pgnode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">PGNode</span><span class="o">.</span><span class="n">to_process_graph_argument</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.apply_dimension"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.apply_dimension">[docs]</a>    <span class="k">def</span> <span class="nf">apply_dimension</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">process</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">version</span><span class="o">=</span><span class="s2">&quot;latest&quot;</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">target_dimension</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a process to all pixel values along a dimension of a raster data cube. For example,</span>
<span class="sd">        if the temporal dimension is specified the process will work on a time series of pixel values.</span>

<span class="sd">        The process to apply is specified by either `code` and `runtime` in case of a UDF, or by providing a callback function</span>
<span class="sd">        in the `process` argument.</span>

<span class="sd">        The process reduce_dimension also applies a process to pixel values along a dimension, but drops</span>
<span class="sd">        the dimension afterwards. The process apply applies a process to each pixel value in the data cube.</span>

<span class="sd">        The target dimension is the source dimension if not specified otherwise in the target_dimension parameter.</span>
<span class="sd">        The pixel values in the target dimension get replaced by the computed pixel values. The name, type and</span>
<span class="sd">        reference system are preserved.</span>

<span class="sd">        The dimension labels are preserved when the target dimension is the source dimension and the number of</span>
<span class="sd">        pixel values in the source dimension is equal to the number of values computed by the process. Otherwise,</span>
<span class="sd">        the dimension labels will be incrementing integers starting from zero, which can be changed using</span>
<span class="sd">        rename_labels afterwards. The number of labels will equal to the number of values computed by the process.</span>

<span class="sd">        :param code: UDF code or process identifier (optional)</span>
<span class="sd">        :param runtime: UDF runtime to use (optional)</span>
<span class="sd">        :param process: a callback function that creates a process graph, see :ref:`callbackfunctions`</span>
<span class="sd">        :param version: Version of the UDF runtime to use</span>
<span class="sd">        :param dimension: The name of the source dimension to apply the process on. Fails with a DimensionNotAvailable error if the specified dimension does not exist.</span>
<span class="sd">        :param target_dimension: The name of the target dimension or null (the default) to use the source dimension</span>
<span class="sd">            specified in the parameter dimension. By specifying a target dimension, the source dimension is removed.</span>
<span class="sd">            The target dimension with the specified name and the type other (see add_dimension) is created, if it doesn&#39;t exist yet.</span>

<span class="sd">        :return: A datacube with the UDF applied to the given dimension.</span>
<span class="sd">        :raises: DimensionNotAvailable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">runtime</span><span class="p">:</span>
            <span class="c1"># TODO EP-3555: unify better with UDF(PGNode) class and avoid doing same UDF code-runtime-version argument stuff in each method</span>
            <span class="n">callback_process_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_run_udf</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">PGNode</span><span class="o">.</span><span class="n">to_process_graph_argument</span><span class="p">(</span><span class="n">callback_process_node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">code</span> <span class="ow">or</span> <span class="n">process</span><span class="p">:</span>
            <span class="c1"># TODO EP-3555 unify `code` and `process`</span>
            <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">code</span> <span class="ow">or</span> <span class="n">process</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpenEoClientException</span><span class="p">(</span><span class="s2">&quot;No UDF code or process given&quot;</span><span class="p">)</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s2">&quot;process&quot;</span><span class="p">:</span> <span class="n">process</span><span class="p">,</span>
            <span class="s2">&quot;dimension&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">assert_valid_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span>
            <span class="c1"># TODO #125 arguments: context</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">target_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;target_dimension&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_dimension</span>
        <span class="n">result_cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;apply_dimension&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result_cube</span></div>

<div class="viewcode-block" id="DataCube.reduce_dimension"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.reduce_dimension">[docs]</a>    <span class="k">def</span> <span class="nf">reduce_dimension</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reducer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;reduce_dimension&quot;</span><span class="p">,</span> <span class="n">band_math_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a reduce process with given reducer callback along given dimension</span>

<span class="sd">        :param dimension: the label of the dimension to reduce</span>
<span class="sd">        :param reducer: a callback function that creates a process graph, see :ref:`callbackfunctions`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: check if dimension is valid according to metadata? #116</span>
        <span class="c1"># TODO: #125 use/test case for `reduce_dimension_binary`?</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_with_node</span><span class="p">(</span><span class="n">ReduceNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="n">process_id</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_pg</span><span class="p">,</span>
            <span class="n">reducer</span><span class="o">=</span><span class="n">reducer</span><span class="p">,</span>
            <span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">assert_valid_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span>
            <span class="c1"># TODO #123 is it (still) necessary to make &quot;band&quot; math a special case?</span>
            <span class="n">band_math_mode</span><span class="o">=</span><span class="n">band_math_mode</span>
            <span class="c1"># TODO: add `context` argument #125</span>
        <span class="p">),</span> <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">reduce_dimension</span><span class="p">(</span><span class="n">dimension_name</span><span class="o">=</span><span class="n">dimension</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_reduce_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reducer</span><span class="p">:</span> <span class="n">PGNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="c1"># TODO #123 is it (still) necessary to make &quot;band&quot; math a special case?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">band_dimension</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="n">reducer</span><span class="p">,</span> <span class="n">band_math_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reduce_temporal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reducer</span><span class="p">:</span> <span class="n">PGNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">temporal_dimension</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="n">reducer</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.reduce_bands_udf"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.reduce_bands_udf">[docs]</a>    <span class="k">def</span> <span class="nf">reduce_bands_udf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;latest&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply reduce (`reduce_dimension`) process with given UDF along band/spectral dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO EP-3555: unify better with UDF(PGNode) class and avoid doing same UDF code-runtime-version argument stuff in each method</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_bands</span><span class="p">(</span><span class="n">reducer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_run_udf</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">version</span><span class="p">))</span></div>

<div class="viewcode-block" id="DataCube.add_dimension"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.add_dimension">[docs]</a>    <span class="k">def</span> <span class="nf">add_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new named dimension to the data cube.</span>
<span class="sd">        Afterwards, the dimension can be referenced with the specified name. If a dimension with the specified name exists,</span>
<span class="sd">        the process fails with a DimensionExists error. The dimension label of the dimension is set to the specified label.</span>

<span class="sd">        This call does not modify the datacube in place, but returns a new datacube with the additional dimension.</span>

<span class="sd">        :param name: The name of the dimension to add</span>
<span class="sd">        :param label: The dimension label.</span>
<span class="sd">        :param type: Dimension type, allowed values: &#39;spatial&#39;, &#39;temporal&#39;, &#39;bands&#39;, &#39;other&#39;, default value is &#39;other&#39;</span>
<span class="sd">        :return: The data cube with a newly added dimension. The new dimension has exactly one dimension label. All other dimensions remain unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;add_dimension&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pg</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">label</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">add_dimension</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_create_run_udf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PGNode</span><span class="p">:</span>
        <span class="c1"># TODO EP-3555: unify better with UDF(PGNode) class</span>
        <span class="k">return</span> <span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;run_udf&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;data&quot;</span>
                <span class="p">},</span>
                <span class="s2">&quot;runtime&quot;</span><span class="p">:</span> <span class="n">runtime</span><span class="p">,</span>
                <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="n">version</span><span class="p">,</span>
                <span class="s2">&quot;udf&quot;</span><span class="p">:</span> <span class="n">code</span>
            <span class="p">})</span>

<div class="viewcode-block" id="DataCube.reduce_temporal_udf"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.reduce_temporal_udf">[docs]</a>    <span class="k">def</span> <span class="nf">reduce_temporal_udf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s2">&quot;latest&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply reduce (`reduce_dimension`) process with given UDF along temporal dimension.</span>

<span class="sd">        :param code: The UDF code, compatible with the given runtime and version</span>
<span class="sd">        :param runtime: The UDF runtime</span>
<span class="sd">        :param version: The UDF runtime version</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO EP-3555: unify better with UDF(PGNode) class and avoid doing same UDF code-runtime-version argument stuff in each method</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_temporal</span><span class="p">(</span><span class="n">reducer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_run_udf</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">version</span><span class="p">))</span></div>

    <span class="n">reduce_tiles_over_time</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">reduce_temporal_udf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;reduce_tiles_over_time&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.apply_neighborhood"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.apply_neighborhood">[docs]</a>    <span class="k">def</span> <span class="nf">apply_neighborhood</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">:</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span>
            <span class="n">size</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> <span class="n">overlap</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a focal process to a data cube.</span>

<span class="sd">        A focal process is a process that works on a &#39;neighbourhood&#39; of pixels. The neighbourhood can extend into multiple dimensions, this extent is specified by the `size` argument. It is not only (part of) the size of the input window, but also the size of the output for a given position of the sliding window. The sliding window moves with multiples of `size`.</span>

<span class="sd">        An overlap can be specified so that neighbourhoods can have overlapping boundaries. This allows for continuity of the output. The values included in the data cube as overlap can&#39;t be modified by the given `process`.</span>

<span class="sd">        The neighbourhood size should be kept small enough, to avoid running beyond computational resources, but a too small size will result in a larger number of process invocations, which may slow down processing. Window sizes for spatial dimensions typically are in the range of 64 to 512 pixels, while overlaps of 8 to 32 pixels are common.</span>

<span class="sd">        The process must not add new dimensions, or remove entire dimensions, but the result can have different dimension labels.</span>

<span class="sd">        For the special case of 2D convolution, it is recommended to use ``apply_kernel()``.</span>

<span class="sd">        :param size:</span>
<span class="sd">        :param overlap:</span>
<span class="sd">        :param process: a callback function that creates a process graph, see :ref:`callbackfunctions`</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;apply_neighborhood&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">process</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]),</span>
                <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
                <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.apply"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a unary process (a local operation) to each value of the specified or all dimensions in the data cube.</span>

<span class="sd">        :param process: the name of a process, or a callback function that creates a process graph, see :ref:`callbackfunctions`</span>
<span class="sd">        :param dimensions: The names of the dimensions to apply the process on. Defaults to an empty array so that all dimensions are used.</span>
<span class="sd">        :return: A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;apply&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
                <span class="s2">&quot;process&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]),</span>
                <span class="c1"># TODO #125 context</span>
            <span class="p">}</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.reduce_temporal_simple"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.reduce_temporal_simple">[docs]</a>    <span class="k">def</span> <span class="nf">reduce_temporal_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Do temporal reduce with a simple given process as callback.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_temporal</span><span class="p">(</span><span class="n">reducer</span><span class="o">=</span><span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="n">process_id</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;from_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;data&quot;</span><span class="p">}}</span>
        <span class="p">))</span></div>

<div class="viewcode-block" id="DataCube.min_time"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.min_time">[docs]</a>    <span class="k">def</span> <span class="nf">min_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Finds the minimum value of a time series for all bands of the input dataset.</span>

<span class="sd">            :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_temporal_simple</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.max_time"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.max_time">[docs]</a>    <span class="k">def</span> <span class="nf">max_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the maximum value of a time series for all bands of the input dataset.</span>

<span class="sd">        :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_temporal_simple</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.mean_time"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.mean_time">[docs]</a>    <span class="k">def</span> <span class="nf">mean_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Finds the mean value of a time series for all bands of the input dataset.</span>

<span class="sd">            :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_temporal_simple</span><span class="p">(</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.median_time"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.median_time">[docs]</a>    <span class="k">def</span> <span class="nf">median_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Finds the median value of a time series for all bands of the input dataset.</span>

<span class="sd">            :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_temporal_simple</span><span class="p">(</span><span class="s2">&quot;median&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.count_time"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.count_time">[docs]</a>    <span class="k">def</span> <span class="nf">count_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of images with a valid mask in a time series for all bands of the input dataset.</span>

<span class="sd">            :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_temporal_simple</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.aggregate_temporal"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.aggregate_temporal">[docs]</a>    <span class="k">def</span> <span class="nf">aggregate_temporal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">],</span><span class="n">reducer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">],</span><span class="n">labels</span><span class="p">:</span><span class="n">List</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span><span class="n">Dict</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Computes a temporal aggregation based on an array of date and/or time intervals.</span>

<span class="sd">            Calendar hierarchies such as year, month, week etc. must be transformed into specific intervals by the clients. For each interval, all data along the dimension will be passed through the reducer. The computed values will be projected to the labels, so the number of labels and the number of intervals need to be equal.</span>

<span class="sd">            If the dimension is not set, the data cube is expected to only have one temporal dimension.</span>

<span class="sd">            :param intervals: Temporal left-closed intervals so that the start time is contained, but not the end time.</span>
<span class="sd">            :param reducer: A reducer to be applied on all values along the specified dimension. The reducer must be a callable process (or a set processes) that accepts an array and computes a single return value of the same type as the input values, for example median.</span>
<span class="sd">            :param labels: Labels for the intervals. The number of labels and the number of groups need to be equal.</span>
<span class="sd">            :param dimension: The temporal dimension for aggregation. All data along the dimension will be passed through the specified reducer. If the dimension is not set, the data cube is expected to only have one temporal dimension.</span>
<span class="sd">            :param context: Additional data to be passed to the reducer. Not set by default.</span>

<span class="sd">            :return: An ImageCollection containing  a result for each time window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;aggregate_temporal&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span> <span class="n">THIS</span><span class="p">,</span>
                <span class="n">intervals</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">,</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">,</span>
                <span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span><span class="p">,</span>
                <span class="n">reducer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>

            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.ndvi"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.ndvi">[docs]</a>    <span class="k">def</span> <span class="nf">ndvi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">red</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_band</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Normalized Difference Vegetation Index (NDVI)</span>

<span class="sd">            :param nir: (optional) name of NIR band</span>
<span class="sd">            :param red: (optional) name of red band</span>
<span class="sd">            :param target_band: (optional) name of the newly created band</span>

<span class="sd">            :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target_band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">reduce_dimension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">band_dimension</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">append_band</span><span class="p">(</span><span class="n">Band</span><span class="p">(</span><span class="n">target_band</span><span class="p">,</span> <span class="s2">&quot;ndvi&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;ndvi&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">nir</span><span class="o">=</span><span class="n">nir</span><span class="p">,</span> <span class="n">red</span><span class="o">=</span><span class="n">red</span><span class="p">,</span> <span class="n">target_band</span><span class="o">=</span><span class="n">target_band</span>
            <span class="p">),</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.rename_dimension"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.rename_dimension">[docs]</a>    <span class="k">def</span> <span class="nf">rename_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames a dimension in the data cube while preserving all other properties.</span>

<span class="sd">        :param source: The current name of the dimension. Fails with a DimensionNotAvailable error if the specified dimension does not exist.</span>
<span class="sd">        :param target: A new Name for the dimension. Fails with a DimensionExists error if a dimension with the specified name exists.</span>

<span class="sd">        :return: A new datacube with the dimension renamed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">dimension_names</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Target dimension name conflicts with existing dimension: </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;rename_dimension&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">assert_valid_dimension</span><span class="p">(</span><span class="n">source</span><span class="p">),</span>
                <span class="n">target</span><span class="o">=</span><span class="n">target</span>
            <span class="p">),</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">rename_dimension</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.rename_labels"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.rename_labels">[docs]</a>    <span class="k">def</span> <span class="nf">rename_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Renames the labels of the specified dimension in the data cube from source to target.</span>

<span class="sd">            :param dimension: Dimension name</span>
<span class="sd">            :param target: The new names for the labels.</span>
<span class="sd">            :param source: The names of the labels as they are currently in the data cube.</span>

<span class="sd">            :return: An DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;rename_labels&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">assert_valid_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span>
                <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">source</span>
            <span class="p">),</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">rename_labels</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">source</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.linear_scale_range"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.linear_scale_range">[docs]</a>    <span class="k">def</span> <span class="nf">linear_scale_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_min</span><span class="p">,</span> <span class="n">input_max</span><span class="p">,</span> <span class="n">output_min</span><span class="p">,</span> <span class="n">output_max</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Color stretching</span>

<span class="sd">        :param input_min: Minimum input value</span>
<span class="sd">        :param input_max: Maximum input value</span>
<span class="sd">        :param output_min: Minimum output value</span>
<span class="sd">        :param output_max: Maximum output value</span>
<span class="sd">        :return: a DataCube instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">process_id</span> <span class="o">=</span> <span class="s1">&#39;linear_scale_range&#39;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;inputMin&#39;</span><span class="p">:</span> <span class="n">input_min</span><span class="p">,</span>
            <span class="s1">&#39;inputMax&#39;</span><span class="p">:</span> <span class="n">input_max</span><span class="p">,</span>
            <span class="s1">&#39;outputMin&#39;</span><span class="p">:</span> <span class="n">output_min</span><span class="p">,</span>
            <span class="s1">&#39;outputMax&#39;</span><span class="p">:</span> <span class="n">output_max</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.mask"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.mask">[docs]</a>    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a mask to a raster data cube. To apply a vector mask use `mask_polygon`.</span>

<span class="sd">        A mask is a raster data cube for which corresponding pixels among `data` and `mask`</span>
<span class="sd">        are compared and those pixels in `data` are replaced whose pixels in `mask` are non-zero</span>
<span class="sd">        (for numbers) or true (for boolean values).</span>
<span class="sd">        The pixel values are replaced with the value specified for `replacement`,</span>
<span class="sd">        which defaults to null (no data).</span>

<span class="sd">        :param mask: the raster mask</span>
<span class="sd">        :param replacement: the value to replace the masked pixels with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">mask</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;from_node&#39;</span><span class="p">:</span> <span class="n">mask</span><span class="o">.</span><span class="n">_pg</span><span class="p">},</span>
                <span class="n">replacement</span><span class="o">=</span><span class="n">replacement</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.mask_polygon"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.mask_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">mask_polygon</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">srs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inside</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a polygon mask to a raster data cube. To apply a raster mask use `mask`.</span>

<span class="sd">        All pixels for which the point at the pixel center does not intersect with any</span>
<span class="sd">        polygon (as defined in the Simple Features standard by the OGC) are replaced.</span>
<span class="sd">        This behaviour can be inverted by setting the parameter `inside` to true.</span>

<span class="sd">        The pixel values are replaced with the value specified for `replacement`,</span>
<span class="sd">        which defaults to `no data`.</span>

<span class="sd">        :param mask: A polygon, provided as a :class:`shapely.geometry.Polygon` or :class:`shapely.geometry.MultiPolygon`, or a filename pointing to a valid vector file</span>
<span class="sd">        :param srs: The reference system of the provided polygon, by default this is Lat Lon (EPSG:4326).</span>
<span class="sd">        :param replacement: the value to replace the masked pixels with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">)):</span>
            <span class="c1"># TODO: default to loading file client side?</span>
            <span class="c1"># TODO: change read_vector to load_uploaded_files https://github.com/Open-EO/openeo-processes/pull/106</span>
            <span class="n">read_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
                <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;read_vector&#39;</span><span class="p">,</span>
                <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;filename&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">mask</span><span class="p">)}</span>
            <span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;from_node&#39;</span><span class="p">:</span> <span class="n">read_vector</span><span class="o">.</span><span class="n">_pg</span><span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseGeometry</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mask </span><span class="si">{m!s}</span><span class="s2"> has an area of </span><span class="si">{a!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">mask</span><span class="o">.</span><span class="n">area</span><span class="p">))</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">mapping</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span>
                <span class="s1">&#39;properties&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">srs</span><span class="p">}</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume mask is already a valid GeoJSON object</span>
            <span class="k">assert</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">mask</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;mask_polygon&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="n">dict_no_none</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">THIS</span><span class="p">,</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                <span class="n">replacement</span><span class="o">=</span><span class="n">replacement</span><span class="p">,</span>
                <span class="n">inside</span><span class="o">=</span><span class="n">inside</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.merge_cubes"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.merge_cubes">[docs]</a>    <span class="k">def</span> <span class="nf">merge_cubes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">,</span> <span class="n">overlap_resolver</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merging two data cubes</span>

<span class="sd">        The data cubes have to be compatible. A merge operation without overlap should be reversible with (a set of) filter operations for each of the two cubes. The process performs the join on overlapping dimensions, with the same name and type.</span>
<span class="sd">        An overlapping dimension has the same name, type, reference system and resolution in both dimensions, but can have different labels. One of the dimensions can have different labels, for all other dimensions the labels must be equal. If data overlaps, the parameter overlap_resolver must be specified to resolve the overlap.</span>

<span class="sd">        Examples for merging two data cubes:</span>

<span class="sd">        #. Data cubes with the dimensions x, y, t and bands have the same dimension labels in x,y and t, but the labels for the dimension bands are B1 and B2 for the first cube and B3 and B4. An overlap resolver is not needed. The merged data cube has the dimensions x, y, t and bands and the dimension bands has four dimension labels: B1, B2, B3, B4.</span>
<span class="sd">        #. Data cubes with the dimensions x, y, t and bands have the same dimension labels in x,y and t, but the labels for the dimension bands are B1 and B2 for the first data cube and B2 and B3 for the second. An overlap resolver is required to resolve overlap in band B2. The merged data cube has the dimensions x, y, t and bands and the dimension bands has three dimension labels: B1, B2, B3.</span>
<span class="sd">        #. Data cubes with the dimensions x, y and t have the same dimension labels in x,y and t. There are two options:</span>
<span class="sd">                * Keep the overlapping values separately in the merged data cube: An overlap resolver is not needed, but for each data cube you need to add a new dimension using add_dimension. The new dimensions must be equal, except that the labels for the new dimensions must differ by name. The merged data cube has the same dimensions and labels as the original data cubes, plus the dimension added with add_dimension, which has the two dimension labels after the merge.</span>
<span class="sd">                * Combine the overlapping values into a single value: An overlap resolver is required to resolve the overlap for all pixels. The merged data cube has the same dimensions and labels as the original data cubes, but all pixel values have been processed by the overlap resolver.</span>
<span class="sd">        #. Merging a data cube with dimensions x, y, t with another cube with dimensions x, y will join on the x, y dimension, so the lower dimension cube is merged with each time step in the higher dimensional cube. This can for instance be used to apply a digital elevation model to a spatiotemporal data cube.</span>

<span class="sd">        :param other: The data cube to merge with.</span>
<span class="sd">        :param overlap_resolver: A reduction operator that resolves the conflict if the data overlaps. The reducer must return a value of the same data type as the input values are. The reduction operator may be a single process such as multiply or consist of multiple sub-processes. null (the default) can be specified if no overlap resolver is required.</span>
<span class="sd">        :return: The merged data cube.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;cube1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;from_node&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pg</span><span class="p">},</span>
            <span class="s1">&#39;cube2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;from_node&#39;</span><span class="p">:</span> <span class="n">other</span><span class="o">.</span><span class="n">_pg</span><span class="p">},</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">overlap_resolver</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;overlap_resolver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_callback</span><span class="p">(</span><span class="n">overlap_resolver</span><span class="p">,</span> <span class="n">parent_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">])</span>
        <span class="c1"># TODO #125 context</span>
        <span class="c1"># TODO: set metadata of reduced cube?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;merge_cubes&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">)</span></div>

    <span class="n">merge</span> <span class="o">=</span> <span class="n">legacy_alias</span><span class="p">(</span><span class="n">merge_cubes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;merge&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.apply_kernel"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.apply_kernel">[docs]</a>    <span class="k">def</span> <span class="nf">apply_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">border</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">replace_invalid</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a focal operation based on a weighted kernel to each value of the specified dimensions in the data cube.</span>

<span class="sd">        The border parameter determines how the data is extended when the kernel overlaps with the borders.</span>
<span class="sd">        The following options are available:</span>

<span class="sd">        * numeric value - fill with a user-defined constant number n: nnnnnn|abcdefgh|nnnnnn (default, with n = 0)</span>
<span class="sd">        * replicate - repeat the value from the pixel at the border: aaaaaa|abcdefgh|hhhhhh</span>
<span class="sd">        * reflect - mirror/reflect from the border: fedcba|abcdefgh|hgfedc</span>
<span class="sd">        * reflect_pixel - mirror/reflect from the center of the pixel at the border: gfedcb|abcdefgh|gfedcb</span>
<span class="sd">        * wrap - repeat/wrap the image: cdefgh|abcdefgh|abcdef</span>


<span class="sd">        :param kernel: The kernel to be applied on the data cube. The kernel has to be as many dimensions as the data cube has dimensions.</span>
<span class="sd">        :param factor: A factor that is multiplied to each value computed by the focal operation. This is basically a shortcut for explicitly multiplying each value by a factor afterwards, which is often required for some kernel-based algorithms such as the Gaussian blur.</span>
<span class="sd">        :param border: Determines how the data is extended when the kernel overlaps with the borders. Defaults to fill the border with zeroes.</span>
<span class="sd">        :param replace_invalid: This parameter specifies the value to replace non-numerical or infinite numerical values with. By default, those values are replaced with zeroes.</span>
<span class="sd">        :return: A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;apply_kernel&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="n">kernel</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">kernel</span><span class="p">,</span>
            <span class="s1">&#39;factor&#39;</span><span class="p">:</span> <span class="n">factor</span><span class="p">,</span>
            <span class="s1">&#39;border&#39;</span><span class="p">:</span> <span class="n">border</span><span class="p">,</span>
            <span class="s1">&#39;replace_invalid&#39;</span><span class="p">:</span> <span class="n">replace_invalid</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.resolution_merge"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.resolution_merge">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">high_resolution_bands</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">low_resolution_bands</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
                         <span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXPERIMENTAL</span>
<span class="sd">        Resolution merging algorithms try to improve the spatial resolution of lower resolution bands</span>
<span class="sd">        (e.g. Sentinel-2 20M) based on higher resolution bands. (e.g. Sentinel-2 10M).</span>

<span class="sd">        External references:</span>

<span class="sd">        `Pansharpening explained &lt;https://bok.eo4geo.eu/IP2-1-3&gt;`_</span>

<span class="sd">        `Example publication: &#39;Improving the Spatial Resolution of Land Surface Phenology by Fusing Medium- and</span>
<span class="sd">        Coarse-Resolution Inputs&#39; &lt;https://doi.org/10.1109/TGRS.2016.2537929&gt;`_</span>

<span class="sd">        :param high_resolution_bands: A list of band names to use as &#39;high-resolution&#39; band. Either the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands). If unique band name and common name conflict, the unique band name has higher priority. The order of the specified array defines the order of the bands in the data cube. If multiple bands match a common name, all matched bands are included in the original order. These bands will remain unmodified.</span>
<span class="sd">        :param low_resolution_bands: A list of band names for which the spatial resolution should be increased. Either the unique band name (metadata field `name` in bands) or one of the common band names (metadata field `common_name` in bands). If unique band name and common name conflict, the unique band name has higher priority. The order of the specified array defines the order of the bands in the data cube. If multiple bands match a common name, all matched bands are included in the original order. These bands will be modified by the process.</span>
<span class="sd">        :param method: The method to use. The supported algorithms can vary between back-ends. Set to `null` (the default) to allow the back-end to choose, which will improve portability, but reduce reproducibility..</span>
<span class="sd">        :return: A datacube with the same bands and metadata as the input, but algorithmically increased spatial resolution for the selected bands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;resolution_merge&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;high_resolution_bands&#39;</span><span class="p">:</span> <span class="n">high_resolution_bands</span><span class="p">,</span>
            <span class="s1">&#39;low_resolution_bands&#39;</span><span class="p">:</span> <span class="n">low_resolution_bands</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>

        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.raster_to_vector"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.raster_to_vector">[docs]</a>    <span class="k">def</span> <span class="nf">raster_to_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorCube</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXPERIMENTAL: not generally supported, API subject to change</span>
<span class="sd">        Converts this raster data cube into a vector data cube. The bounding polygon of homogenous areas of pixels is constructed.</span>

<span class="sd">        :return: A vectorcube</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">VectorCube</span><span class="p">(</span><span class="n">PGNode</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s1">&#39;raster_to_vector&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pg</span>
            <span class="p">}),</span><span class="n">connection</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span></div>

    <span class="c1">####VIEW methods #######</span>

<div class="viewcode-block" id="DataCube.polygonal_mean_timeseries"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.polygonal_mean_timeseries">[docs]</a>    <span class="k">def</span> <span class="nf">polygonal_mean_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a mean time series for the given (multi)polygon. Its points are</span>
<span class="sd">        expected to be in the EPSG:4326 coordinate</span>
<span class="sd">        reference system.</span>

<span class="sd">        :param polygon: The (multi)polygon; or a file path or HTTP URL to a GeoJSON file or shape file</span>
<span class="sd">        :return: DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygonal_timeseries</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.polygonal_histogram_timeseries"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.polygonal_histogram_timeseries">[docs]</a>    <span class="k">def</span> <span class="nf">polygonal_histogram_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a histogram time series for the given (multi)polygon. Its points are</span>
<span class="sd">        expected to be in the EPSG:4326 coordinate</span>
<span class="sd">        reference system.</span>

<span class="sd">        :param polygon: The (multi)polygon; or a file path or HTTP URL to a GeoJSON file or shape file</span>
<span class="sd">        :return: DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygonal_timeseries</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="s2">&quot;histogram&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.polygonal_median_timeseries"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.polygonal_median_timeseries">[docs]</a>    <span class="k">def</span> <span class="nf">polygonal_median_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a median time series for the given (multi)polygon. Its points are</span>
<span class="sd">        expected to be in the EPSG:4326 coordinate</span>
<span class="sd">        reference system.</span>

<span class="sd">        :param polygon: The (multi)polygon; or a file path or HTTP URL to a GeoJSON file or shape file</span>
<span class="sd">        :return: DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygonal_timeseries</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.polygonal_standarddeviation_timeseries"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.polygonal_standarddeviation_timeseries">[docs]</a>    <span class="k">def</span> <span class="nf">polygonal_standarddeviation_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a time series of standard deviations for the given (multi)polygon. Its points are</span>
<span class="sd">        expected to be in the EPSG:4326 coordinate</span>
<span class="sd">        reference system.</span>

<span class="sd">        :param polygon: The (multi)polygon; or a file path or HTTP URL to a GeoJSON file or shape file</span>
<span class="sd">        :return: DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygonal_timeseries</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="s2">&quot;sd&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_polygonal_timeseries</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">func</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PGNode</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_spatial</span><span class="p">(</span><span class="n">geometries</span><span class="o">=</span><span class="n">polygon</span><span class="p">,</span> <span class="n">reducer</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>

<div class="viewcode-block" id="DataCube.ard_surface_reflectance"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.ard_surface_reflectance">[docs]</a>    <span class="k">def</span> <span class="nf">ard_surface_reflectance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atmospheric_correction_method</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="n">cloud_detection_method</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="n">elevation_model</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes CARD4L compliant surface reflectance values from optical input.</span>

<span class="sd">        :param atmospheric_correction_method: The atmospheric correction method to use.</span>
<span class="sd">        :param cloud_detection_method: The cloud detection method to use.</span>
<span class="sd">        :param elevation_model: The digital elevation model to use, leave empty to allow the back-end to make a suitable choice.</span>
<span class="sd">        :return: Data cube containing bottom of atmosphere reflectances with atmospheric disturbances like clouds and cloud shadows removed. The data returned is CARD4L compliant and contains metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;atmospheric_correction&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;atmospheric_correction_method&#39;</span><span class="p">:</span> <span class="n">atmospheric_correction_method</span><span class="p">,</span>
            <span class="s1">&#39;cloud_detection_method&#39;</span><span class="p">:</span><span class="n">cloud_detection_method</span><span class="p">,</span>
            <span class="s1">&#39;elevation_model&#39;</span><span class="p">:</span><span class="n">elevation_model</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.atmospheric_correction"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.atmospheric_correction">[docs]</a>    <span class="k">def</span> <span class="nf">atmospheric_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">elevation_model</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies an atmospheric correction that converts top of atmosphere reflectance values into bottom of atmosphere/top of canopy reflectance values.</span>

<span class="sd">        Note that multiple atmospheric methods exist, but may not be supported by all backends. The method parameter gives</span>
<span class="sd">        you the option of requiring a specific method, but this may result in an error if the backend does not support it.</span>

<span class="sd">        :param method: The atmospheric correction method to use. To get reproducible results, you have to set a specific method. Set to `null` to allow the back-end to choose, which will improve portability, but reduce reproducibility as you *may* get different results if you run the processes multiple times.</span>
<span class="sd">        :param elevation_model: The digital elevation model to use, leave empty to allow the back-end to make a suitable choice.</span>
<span class="sd">        :return: datacube with bottom of atmosphere reflectances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s1">&#39;atmospheric_correction&#39;</span><span class="p">,</span> <span class="p">{</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;elevation_model&#39;</span><span class="p">:</span> <span class="n">elevation_model</span>
        <span class="p">})</span></div>

    <span class="k">def</span> <span class="nf">save_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;GTiff&quot;</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DataCube&#39;</span><span class="p">:</span>
        <span class="n">formats</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">list_output_formats</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">formats</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid format </span><span class="si">{f!r}</span><span class="s2">. Should be one of </span><span class="si">{s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">formats</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span>
            <span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;save_result&quot;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
                <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="nb">format</span><span class="p">,</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="n">options</span> <span class="ow">or</span> <span class="p">{}</span>
            <span class="p">}</span>
        <span class="p">)</span>

<div class="viewcode-block" id="DataCube.download"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.download">[docs]</a>    <span class="k">def</span> <span class="nf">download</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;GTIFF&quot;</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Download image collection, e.g. as GeoTIFF.</span>
<span class="sd">        If outputfile is provided, the result is stored on disk locally, otherwise, a bytes object is returned.</span>
<span class="sd">        The bytes object can be passed on to a suitable decoder for decoding.</span>

<span class="sd">        :param outputfile: Optional, an output file if the result needs to be stored on disk.</span>
<span class="sd">        :param format: Optional, defaults to &quot;GTIFF&quot;, an output format supported by the backend.</span>
<span class="sd">        :param options: Optional, file format options</span>
<span class="sd">        :return: None if the result is stored to disk, or a bytes object returned by the backend.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_result</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">cube</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">(),</span> <span class="n">outputfile</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.tiled_viewing_service"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.tiled_viewing_service">[docs]</a>    <span class="k">def</span> <span class="nf">tiled_viewing_service</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">create_service</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">(),</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.execute_batch"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.execute_batch">[docs]</a>    <span class="k">def</span> <span class="nf">execute_batch</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">outputfile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="nb">print</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span> <span class="n">max_poll_interval</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">connection_retry_interval</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
            <span class="n">job_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">format_options</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RESTJob</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the process graph by creating a batch job, and retrieving the results when it is finished.</span>
<span class="sd">        This method is mostly recommended if the batch job is expected to run in a reasonable amount of time.</span>

<span class="sd">        For very long running jobs, you probably do not want to keep the client running.</span>

<span class="sd">        :param job_options:</span>
<span class="sd">        :param outputfile: The path of a file to which a result can be written</span>
<span class="sd">        :param out_format: (optional) Format of the job result.</span>
<span class="sd">        :param format_options: String Parameters for the job result format</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">job</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_job</span><span class="p">(</span><span class="n">out_format</span><span class="p">,</span> <span class="n">job_options</span><span class="o">=</span><span class="n">job_options</span><span class="p">,</span> <span class="o">**</span><span class="n">format_options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">job</span><span class="o">.</span><span class="n">run_synchronous</span><span class="p">(</span>
            <span class="n">outputfile</span><span class="o">=</span><span class="n">outputfile</span><span class="p">,</span>
            <span class="nb">print</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span> <span class="n">max_poll_interval</span><span class="o">=</span><span class="n">max_poll_interval</span><span class="p">,</span> <span class="n">connection_retry_interval</span><span class="o">=</span><span class="n">connection_retry_interval</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.send_job"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.send_job">[docs]</a>    <span class="k">def</span> <span class="nf">send_job</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">out_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plan</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">budget</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">job_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">format_options</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RESTJob</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sends a job to the backend and returns a Job instance. The job will still need to be started and managed explicitly.</span>
<span class="sd">        The :func:`~openeo.imagecollection.ImageCollection.execute_batch` method allows you to run batch jobs without managing it.</span>

<span class="sd">        :param out_format: String Format of the job result.</span>
<span class="sd">        :param job_options: A dictionary containing (custom) job options</span>
<span class="sd">        :param format_options: String Parameters for the job result format</span>
<span class="sd">        :return: status: Job resulting job.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">out_format</span><span class="p">:</span>
            <span class="c1"># add `save_result` node</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">save_result</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">out_format</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">format_options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">create_job</span><span class="p">(</span>
            <span class="n">process_graph</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">(),</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">plan</span><span class="o">=</span><span class="n">plan</span><span class="p">,</span> <span class="n">budget</span><span class="o">=</span><span class="n">budget</span><span class="p">,</span> <span class="n">additional</span><span class="o">=</span><span class="n">job_options</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.save_user_defined_process"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.save_user_defined_process">[docs]</a>    <span class="k">def</span> <span class="nf">save_user_defined_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_defined_process_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">public</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">summary</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RESTUserDefinedProcess</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves this process graph in the backend as a user-defined process for the authenticated user.</span>

<span class="sd">        :param user_defined_process_id: unique identifier for the process</span>
<span class="sd">        :param public: visible to other users?</span>
<span class="sd">        :param summary: A short summary of what the process does.</span>
<span class="sd">        :param description: Detailed description to explain the entity. CommonMark 0.29 syntax MAY be used for rich text representation.</span>
<span class="sd">        :return: a RESTUserDefinedProcess instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">save_user_defined_process</span><span class="p">(</span>
            <span class="n">user_defined_process_id</span><span class="o">=</span><span class="n">user_defined_process_id</span><span class="p">,</span>
            <span class="n">process_graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">(),</span> <span class="n">public</span><span class="o">=</span><span class="n">public</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="n">summary</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataCube.execute"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Executes the process graph of the imagery. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">())</span></div>

<div class="viewcode-block" id="DataCube.execute_local_udf"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.execute_local_udf">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">execute_local_udf</span><span class="p">(</span><span class="n">udf</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">datacube</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;xarray.DataArray&#39;</span><span class="p">,</span> <span class="s1">&#39;openeo_udf.api.datacube.DataCube&#39;</span><span class="p">]</span> <span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;netcdf&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Locally executes an user defined function on a previously downloaded datacube.</span>
<span class="sd">        </span>
<span class="sd">        :param udf: the code of the user defined function</span>
<span class="sd">        :param datacube: the path to the downloaded data in disk or a DataCube</span>
<span class="sd">        :param fmt: format of the file if datacube is string</span>
<span class="sd">        :return: the resulting DataCube</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openeo_udf.api.udf_data</span> <span class="kn">import</span> <span class="n">UdfData</span>
        <span class="kn">from</span> <span class="nn">openeo_udf.api.run_code</span> <span class="kn">import</span> <span class="n">run_user_code</span>
        <span class="kn">from</span> <span class="nn">openeo_udf.api.datacube</span> <span class="kn">import</span> <span class="n">DataCube</span> <span class="k">as</span> <span class="n">udf_DataCube</span>
        <span class="kn">from</span> <span class="nn">xarray</span> <span class="kn">import</span> <span class="n">DataArray</span>
        
        <span class="n">udf_data</span><span class="o">=</span><span class="kc">None</span>
        <span class="c1"># if it is a datacube</span>
        <span class="k">if</span> <span class="n">datacube</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get input</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datacube</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">openeo.rest.conversions</span> <span class="kn">import</span> <span class="n">datacube_from_file</span>
                <span class="n">d</span><span class="o">=</span><span class="n">datacube_from_file</span><span class="p">(</span><span class="n">datacube</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datacube</span><span class="p">,</span> <span class="n">udf_DataCube</span><span class="p">):</span>
                <span class="n">d</span><span class="o">=</span><span class="n">datacube</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datacube</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
                <span class="n">d</span><span class="o">=</span><span class="n">udf_DataCube</span><span class="p">(</span><span class="n">datacube</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Data should be either file name to the Data or a DataCube, got &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">datacube</span><span class="o">.</span><span class="vm">__class__</span> <span class="k">if</span> <span class="n">datacube</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;None&#39;</span><span class="p">))</span>
            <span class="c1"># datacube&#39;s data is to be float and x,y not provided</span>
            <span class="n">d</span><span class="o">=</span><span class="n">udf_DataCube</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># wrap to udf_data</span>
            <span class="n">udf_data</span><span class="o">=</span><span class="n">UdfData</span><span class="p">(</span><span class="n">datacube_list</span><span class="o">=</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
            
        <span class="c1"># TODO: enrich to other types like time series, vector data,... probalby by adding  named arguments</span>
        <span class="c1"># signature: UdfData(proj, datacube_list, feature_collection_list, structured_data_list, ml_model_list, metadata)</span>
        
        <span class="c1"># run the udf through the same routine as it would have been parsed in the backend</span>
        <span class="k">if</span> <span class="n">udf_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">=</span><span class="n">run_user_code</span><span class="p">(</span><span class="n">udf</span><span class="p">,</span> <span class="n">udf_data</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="DataCube.to_graphviz"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.to_graphviz">[docs]</a>    <span class="k">def</span> <span class="nf">to_graphviz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a graphviz DiGraph from the process graph</span>

<span class="sd">        :return: graphviz graph object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=import-error, import-outside-toplevel</span>
        <span class="kn">import</span> <span class="nn">graphviz</span>
        <span class="kn">import</span> <span class="nn">pprint</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="n">node_attr</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;fontname&quot;</span><span class="p">:</span> <span class="s2">&quot;sans&quot;</span><span class="p">,</span> <span class="s2">&quot;fontsize&quot;</span><span class="p">:</span> <span class="s2">&quot;11&quot;</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">process</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat_graph</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;arguments&quot;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="c1"># Build label</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;&lt;&lt;TABLE BORDER=&quot;0&quot; CELLBORDER=&quot;1&quot; CELLSPACING=&quot;0&quot;&gt;&#39;</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="s1">&#39;&lt;TR&gt;&lt;TD COLSPAN=&quot;2&quot; BGCOLOR=&quot;#eeeeee&quot;&gt;</span><span class="si">{pid}</span><span class="s1">&lt;/TD&gt;&lt;/TR&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pid</span><span class="o">=</span><span class="n">process</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;process_id&quot;</span><span class="p">,</span><span class="s2">&quot;unknown&quot;</span><span class="p">))</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="sd">&#39;&#39;&#39;&lt;TR&gt;&lt;TD ALIGN=&quot;RIGHT&quot;&gt;{arg}&lt;/TD&gt;</span>
<span class="sd">                       &lt;TD ALIGN=&quot;LEFT&quot;&gt;&lt;FONT FACE=&quot;monospace&quot;&gt;{value}&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">arg</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">v</span><span class="p">)[:</span><span class="mi">1000</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;BR/&gt;&#39;</span><span class="p">)</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="s1">&#39;&lt;/TABLE&gt;&gt;&#39;</span>
            <span class="c1"># Add node and edges to graph</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;from_node&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="n">graph</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s2">&quot;from_node&quot;</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>

            <span class="c1"># TODO: add subgraph for &quot;reducer&quot; arguments?</span>

        <span class="k">return</span> <span class="n">graph</span></div>

<div class="viewcode-block" id="DataCube.ard_normalized_radar_backscatter"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.ard_normalized_radar_backscatter">[docs]</a>    <span class="k">def</span> <span class="nf">ard_normalized_radar_backscatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elevation_model</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">contributing_area</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">ellipsoid_incidence_angle</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">noise_removal</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes CARD4L compliant backscatter (gamma0) from SAR input. This method is a variant of :meth:`openeo.rest.datacube.DataCube.sar_backscatter`,</span>
<span class="sd">         with restricted parameters to generate backscatter according to CARD4L specifications.</span>

<span class="sd">        Note that backscatter computation may require instrument specific metadata that is tightly coupled to the original SAR products.</span>
<span class="sd">        As a result, this process may only work in combination with loading data from specific collections, not with general data cubes.</span>

<span class="sd">        :param elevation_model: The digital elevation model to use. Set to None (the default) to allow the back-end to choose, which will improve portability, but reduce reproducibility.</span>
<span class="sd">        :param contributing_area: If set to `true`, a DEM-based local contributing area band named `contributing_area`</span>
<span class="sd">            is added. The values are given in square meters.</span>
<span class="sd">        :param ellipsoid_incidence_angle: If set to `True`, an ellipsoidal incidence angle band named `ellipsoid_incidence_angle` is added. The values are given in degrees.</span>
<span class="sd">        :param noise_removal: If set to `false`, no noise removal is applied. Defaults to `True`, which removes noise.</span>

<span class="sd">        :return: Backscatter values expressed as gamma0. The data returned is CARD4L compliant and contains metadata. By default, the backscatter values are given in linear scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;ard_normalized_radar_backscatter&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s2">&quot;elevation_model&quot;</span><span class="p">:</span> <span class="n">elevation_model</span><span class="p">,</span>
            <span class="s2">&quot;contributing_area&quot;</span><span class="p">:</span> <span class="n">contributing_area</span><span class="p">,</span>
            <span class="s2">&quot;ellipsoid_incidence_angle&quot;</span><span class="p">:</span> <span class="n">ellipsoid_incidence_angle</span><span class="p">,</span>
            <span class="s2">&quot;noise_removal&quot;</span><span class="p">:</span> <span class="n">noise_removal</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="DataCube.sar_backscatter"><a class="viewcode-back" href="../../../api.html#openeo.rest.datacube.DataCube.sar_backscatter">[docs]</a>    <span class="k">def</span> <span class="nf">sar_backscatter</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">coefficient</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gamma0-terrain&quot;</span><span class="p">,</span>
            <span class="n">elevation_model</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">contributing_area</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">local_incidence_angle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">ellipsoid_incidence_angle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">noise_removal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataCube&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes backscatter from SAR input.</span>

<span class="sd">        Note that backscatter computation may require instrument specific metadata that is tightly coupled to the</span>
<span class="sd">        original SAR products. As a result, this process may only work in combination with loading data from</span>
<span class="sd">        specific collections, not with general data cubes.</span>

<span class="sd">        :param coefficient: Select the radiometric correction coefficient.</span>
<span class="sd">            The following options are available:</span>

<span class="sd">            - `&quot;beta0&quot;`: radar brightness</span>
<span class="sd">            - `&quot;sigma0-ellipsoid&quot;`: ground area computed with ellipsoid earth model</span>
<span class="sd">            - `&quot;sigma0-terrain&quot;`: ground area computed with terrain earth model</span>
<span class="sd">            - `&quot;gamma0-ellipsoid&quot;`: ground area computed with ellipsoid earth model in sensor line of sight</span>
<span class="sd">            - `&quot;gamma0-terrain&quot;`: ground area computed with terrain earth model in sensor line of sight (default)</span>
<span class="sd">            - `None`: non-normalized backscatter</span>
<span class="sd">        :param elevation_model: The digital elevation model to use. Set to `None` (the default) to allow</span>
<span class="sd">            the back-end to choose, which will improve portability, but reduce reproducibility.</span>
<span class="sd">        :param mask: If set to `true`, a data mask is added to the bands with the name `mask`.</span>
<span class="sd">            It indicates which values are valid (1), invalid (0) or contain no-data (null).</span>
<span class="sd">        :param contributing_area: If set to `true`, a DEM-based local contributing area band named `contributing_area`</span>
<span class="sd">            is added. The values are given in square meters.</span>
<span class="sd">        :param local_incidence_angle: If set to `true`, a DEM-based local incidence angle band named</span>
<span class="sd">            `local_incidence_angle` is added. The values are given in degrees.</span>
<span class="sd">        :param ellipsoid_incidence_angle: If set to `true`, an ellipsoidal incidence angle band named</span>
<span class="sd">            `ellipsoid_incidence_angle` is added. The values are given in degrees.</span>
<span class="sd">        :param noise_removal: If set to `false`, no noise removal is applied. Defaults to `true`, which removes noise.</span>
<span class="sd">        :param options: dictionary with additional (backend-specific) options.</span>
<span class="sd">        :return:</span>

<span class="sd">        .. versionadded :: 0.4.9</span>
<span class="sd">        .. versionchanged :: 0.4.10 replace `orthorectify` and `rtc` arguments with `coefficient`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coefficient_options</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;beta0&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma0-ellipsoid&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma0-terrain&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma0-ellipsoid&quot;</span><span class="p">,</span> <span class="s2">&quot;gamma0-terrain&quot;</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">coefficient</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coefficient_options</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpenEoClientException</span><span class="p">(</span><span class="s2">&quot;Invalid `sar_backscatter` coefficient </span><span class="si">{c!r}</span><span class="s2">. Should be one of </span><span class="si">{o}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">c</span><span class="o">=</span><span class="n">coefficient</span><span class="p">,</span> <span class="n">o</span><span class="o">=</span><span class="n">coefficient_options</span>
            <span class="p">))</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">THIS</span><span class="p">,</span>
            <span class="s2">&quot;coefficient&quot;</span><span class="p">:</span> <span class="n">coefficient</span><span class="p">,</span>
            <span class="s2">&quot;elevation_model&quot;</span><span class="p">:</span> <span class="n">elevation_model</span><span class="p">,</span>
            <span class="s2">&quot;mask&quot;</span><span class="p">:</span> <span class="n">mask</span><span class="p">,</span>
            <span class="s2">&quot;contributing_area&quot;</span><span class="p">:</span> <span class="n">contributing_area</span><span class="p">,</span>
            <span class="s2">&quot;local_incidence_angle&quot;</span><span class="p">:</span> <span class="n">local_incidence_angle</span><span class="p">,</span>
            <span class="s2">&quot;ellipsoid_incidence_angle&quot;</span><span class="p">:</span> <span class="n">ellipsoid_incidence_angle</span><span class="p">,</span>
            <span class="s2">&quot;noise_removal&quot;</span><span class="p">:</span> <span class="n">noise_removal</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">process_id</span><span class="o">=</span><span class="s2">&quot;sar_backscatter&quot;</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">)</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2017 - 2021, Jeroen Dries.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/Open-EO/openeo-python-client" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>